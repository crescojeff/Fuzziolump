<html>
<head>
<script>
var Config = {history:{maxStates:0}};
var State = {variables:{}};

Config.history.maxStates = 0;   // no history limit
//alert("config ctor: "+Config.constructor);
var known_id_nuvi = false;
var test = 0;

/** attempts to parse a given function's signature to determine expected params

ex.
function myCustomFn(arg1, arg2,arg3) {
  
}
console.log(getParams(myCustomFn)); // returns ["arg1", "arg2", "arg3"]
*/
window.getParams = function(func) {
  // First match everything inside the function argument parens.
  var args = func.toString().match(/function\s.*?\(([^)]*)\)/)[1];
 
  // Split the arguments string into an array comma delimited.
  return args.split(',').map(function(arg) {
    // Ensure no inline comments are parsed and trim the whitespace.
    return arg.replace(/\/\*.*\*\//, '').trim();
  }).filter(function(arg) {
    // Ensure no undefined values are added.
    return arg;
  });
}

window.addUniqueToArray = function(array,element){
	if(!array.includes(element)){
		array.push(element);	
	}
}

window.addUniqueToArray = function(array,element,filterFn){
	if(!array.some(filterFn)){
		array.push(element);	
	}
}

/**
Get a random Character object from an array of Character objects that can't have the given Character ID
*/
window.randoCharacterFromArrayExceptId = function(characterArray,exceptCharacterId){
		var eligibleCharacters = characterArray.filter(characterUnderTest => characterUnderTest.id != exceptCharacterId);
		var unluckyIndex = Math.floor(Math.random() * eligibleCharacters.length);
		return eligibleCharacters[unluckyIndex];
		
	}

/**
Applies the combat status effect to the given character, adding it to their list of statuses and triggering its effect fn
@param character the recipient of the effect
@param effect the status effect to apply
*/
window.addUniqueStatusEffect = function(character,effect){
	var statuses = character.statusEffects;
	if(!statuses.some(effectUnderTest => effect.id === effectUnderTest.id)){
		statuses.push(effect);
		effect.effect(character);
	}
}

/**
Applies the combat status effect to the given target character, adding it to their list of statuses and triggering its effect fn.
The source character is the one who inflicted the status; this function should be used when a status effect's effect depends on the inflicting character.
@param sourceCharacter the one who inflicted the status
@param targetCharacter the recipient of the effect
@param effect the status effect to apply
*/
window.addUniqueStatusEffectWithSource = function(sourceCharacter, targetCharacter,effect){
	var statuses = targetCharacter.statusEffects;
	if(!statuses.some(effectUnderTest => effect.id === effectUnderTest.id)){
		statuses.push(effect);
		effect.effect(sourceCharacter,targetCharacter);
	}
}

/**
Checks a given character for a given statyus effect
@param character the Character under test
@param effect the StatusEffect we're looking for
@return true if the status effect is found, false otherwise
*/
window.hasStatusEffect = function(character,effect){
	var statuses = character.statusEffects;
	if(statuses.some(effectUnderTest => effect.id === effectUnderTest.id)){
		return true;
	}else{
		return false;	
	}
}

/**
Checks a given character for a given status effect and returns the discovered status effect instance
@param character the Character under test
@param effectId the ID of the StatusEffect we're looking for
@return the status effect instance if found, otherwise undefined
*/
window.getStatusEffect = function(character,effectId){
	var statuses = character.statusEffects;
	return statuses.find(effectUnderTest => effectId === effectUnderTest.id);
}

// find index of a particular character id in a character array
window.findCharacterIndex = function(characterArray,characterID){
	return characterArray.findIndex(function (character){
		return character.id === characterID;
	});	
}

/**
Adds this character to the $party iff they are not already a member
@param character Character object to be added
*/
window.addUniqueCharacterToParty = function(character){
	var party = State.variables.party;
	if(!party.some(characterUnderTest => character.id === characterUnderTest.id)){
		party.push(character);
	}
}

/**
Returns a Character object from the array whose id matches the given id
*/
window.findCharacterInArrayById = function(characterId,array){
	return array.find(characterUnderTest => characterId === characterUnderTest.id);
}

/**
Returns true if any Character object from the array has an id that matches the given id
*/
window.isCharacterWithIdInArray = function(characterId,array){
	return array.some(characterUnderTest => characterId === characterUnderTest.id);
}

/**
Removes a Character from an array of Characters using splice()
@parm character the Character to be removed from the array
@param characterArray the array of Characters
*/
window.removeCharacterFromArray = function(character,characterArray){
	// find the index of the target character in the array
	var index = window.findCharacterIndex(characterArray,character.id);
	// splice the character out of the array; this modified the given array
	characterArray.splice(index,1); 
}
/* // not very space friendly
window.removeCharacterFromArray = function(character,characterArray){
	return characterArray.filter(characterUnderTest =>
		characterUnderTest.id != character.id
	);	
}
*/
																	
window.findCurrentPlayerCharacterIndex = function(){
	return State.variables.combatArena.playerParty.findIndex(function (character){
		console.log("finding current player char index -- checking character "+character.id+" against turn owner "+State.variables.combatArena.turnOwner);
		return character.id === State.variables.combatArena.turnOwner;
	});	
}
window.findLastLivingCharacter = function(characterArray){
	var index = 0;
	for(index = characterArray.length-1; index >= 0; index--){
		var fullCharacter = State.variables.characters[characterArray[index].id];
		console.log("findLastLivingCharacter; character with id "+characterArray[index].id+" is "+(fullCharacter.living?"living":"dead"));
		if(fullCharacter.living){
			return fullCharacter;
		}
	}
}
window.findFirstLivingCharacter = function(characterArray){
	var index = 0;
	for(index = 0; index < characterArray.length; index++){
		var fullCharacter = State.variables.characters[characterArray[index].id];
		console.log("findFirstLivingCharacter; character with id "+characterArray[index].id+" is "+(fullCharacter.living?"living":"dead"));
		if(fullCharacter.living){
			return fullCharacter;
		}
	}
}
window.findNextLivingCharacter = function(characterArray,startingIndex){
	var index = 0;
	for(index = startingIndex; index < characterArray.length; index++){
		var fullCharacter = State.variables.characters[characterArray[index].id];
		console.log("findNextLivingCharacter; character with id "+characterArray[index].id+" is "+(fullCharacter.living?"living":"dead"));
		if(fullCharacter.living){
			return fullCharacter;
		}
	}
}

/**
This shouldn't be... see github issue #2

Takes id property of the given character array, looks up the character object from $characters based on the id, and adds said character object to a new array.  This new array is returned.
*/
window.drawCharacterArrayFromCharactersDict = function(characterArray){
	var actualChars = [];
	for(let character of characterArray){
		actualChars.push(State.variables.characters[character.id]);
	}
	return actualChars;
}

// simulate a d20 roll
window.rollD20 = function(){
	return Math.floor(Math.random() * 20) + 1;
}

// simulate a dN roll, where N is given by sides param
window.rollDie = function(sides){
	return Math.floor(Math.random() * sides) + 1;
}

// simulate a d% roll
window.rollPercentage = function(){
	return Math.floor(Math.random() * 100) + 1;
}

// calculate the ability modifier per Pathfinder rules
window.calcMod = function(ablScore){
	return Math.floor((ablScore-10)/2);
}

// perform an ability score check
window.checkAbility = function(characterObject, attributeString){
	return window.rollD20() + window.calcMod(characterObject.attributes[attributeString]);	
}

window.addToInductiveBias = function(inductiveBiasArray, args){
	for(var biasitem of args){
		if(!inductiveBiasArray.includes(biasitem)){
			inductiveBiasArray.push(biasitem);
		}
	}
}

window.deleteTitle = function(title){
	var playerTitleArray = State.variables.characters["player"].titles;
	var titleIndex = playerTitleArray.indexOf(title);
	if(titleIndex > -1){
			// remove one element from the array, starting at the target index
			playerTitleArray.splice(titleIndex,1);
	}
}

window.addTitle = function(title){
	var playerTitleArray = State.variables.characters["player"].titles;
	if(!playerTitleArray.includes(title)){
			playerTitleArray.push(title);
	}
}

/// begin main quest vars ///
// wipe out the godlings and anybody nearby
window.godling_strat_viral_violence = "viral_violence";
// disrupt the godlings' godlingness in the hopes this might check them or even restore them to their former selves
window.godling_strat_surgical_system = "surgical_system";
// friendship for everyone!  Trying to use Incarnation to get through to each godling
window.godling_strat_diplomancy = "diplomancy";
State.variables.godling_strat_chosen = "";
/// end main quest vars ///

window.removeStatusEffect = function(character,effect){
		var effectIndex = character.statusEffects.findIndex(function(element){
			return element.id === effect.id;
		});
		character.statusEffects.splice(effectIndex,1);
}

window.StatusEffect = function StatusEffect(config){
	if(config.hasOwnProperty('buffity')){
		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{
		this.id = config.id;
		this.name = config.name;
		this.duration = config.duration;
		this.ticks = config.duration;
		/** 
		boon or bane (or y'know the industry standard buff and debuff) would have made more sense, but I was tired and now I like buffins/bluffins.  Anyway, this property identifies a StatusEffect as positive or negative for the afflicted Character where buffins is good and bluffins is bad.  Fight me codereview SE.
		*/
		this.buffity = "buffins";
		this.descriptors = [];
	}// end new instance ctor
} // end StatusEffect class def

// StatusEffect class prototype def
window.StatusEffect.prototype.tickDown = function(){
		this.ticks--;	
	}
	window.StatusEffect.prototype.effect = function(afflictedChar){
		console.log("status effect unset");	
	}
	window.StatusEffect.prototype.reverseEffect = function(afflictedChar){
		console.log("status effect reversal unset");	
	}
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.StatusEffect.prototype.toJSON = function () {

	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);

	// Return a code string that will create a new instance
	// of Ability with our current data.
	return JSON.reviveWrapper(
		'new window.StatusEffect($ReviveData$)',
		data
	);
};
window.StatusEffect.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.StatusEffect(
		this
	);
};
// todo: all classes with stateful properties not covered in ctor params will need the de/serialization treatment that Combat got in order to save/load their full state details
window.Ability = function Ability(config){
	if (config.hasOwnProperty('cost')) {
		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{


	this.id = config.id;
	this.name = config.name;
	
	// metadata about who the ability targets, namely you, all allies, one enemy, or all enemies.
	this.targetType = window.Ability.TargetTypesEnum.singleEnemy; 
	
	/**
	The friendly property describes whether an ability is considered hostile or beneficial to its target
	*/
	this.friendly = false;
	
	// cached value of last calculated dmg
	this.dmg = 0;
	
	/**
	The cost of using using the ability to the user.  It is given as
	an object map with keys that correspond to mutable resource stats associated with integer values.  The given value should be subtracted from the corresponding stat resource pool.
	*/
	this.cost = {"mp":0};
	
	// effect can be defined when Ability instance is defined, but usual behavior will generally be target character's HP reduced by calcDmg().  Default behavior will be to simply log a noop like the other default functions
	this.effect = function(sourceChar,targetChar){console.log("no effect from "+this.name)};
	this.calcDC = function(user,modifyingAttr){
		return 10;	
	}// end calcDC()
	// lambda stub - dmg formula will be defined when Ability instance is defined
	this.calcDmg = function(sourceChar,targetChar){console.log("no dmg from "+this.name)}
	this.generateFlavorText = function(sourceChar,targetChar){console.log("flavor text undefined for "+this.name)}

	}// end new instance ctor
	
} // end Ability def
// static Ability class members
window.Ability.TargetTypesEnum = Object.freeze (
		{ 
			singleEnemy: 1, 
			allEnemies: 2,
			singleAlly: 3,
			allAllies: 4
		});
// Ability class prototype members
/**
	Process the cost of the ability, parsing the cost object map
	*/
window.Ability.prototype.processCost = function(character){
		for(let statCost in this.cost){
			character.stats[statCost] -= this.cost[statCost];	
		}
	}
/**
	Formats the total cost as a string and returns it
	*/
	window.Ability.prototype.printCost = function(){
		var costString = "";
		var costKeys = Object.keys(this.cost);
		for(let index=0;index<costKeys.length-1;index++){
			// for all but the last element...
			costString +=	costKeys[index]+" : "+this.cost[costKeys[index]];
			costString += ", "
		}
		// final cost element, no comma needed
		costString += costKeys[costKeys.length-1]+" : "+this.cost[costKeys[costKeys.length-1]];
		return costString;
	}
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.Ability.prototype.toJSON = function() {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
    return JSON.reviveWrapper('new window.Ability($ReviveData$)',data);
};
window.Ability.prototype.clone = function() {
    // Return a new instance containing our current data.
    return new window.Ability(
        this
    );
};

window.Incarnation = function Incarnation(config){
	// Incarnation inherits from Ability
	window.Ability.call(this,config);
	
}
// establish window.Incarnation.prototype as a proto link extending the Character proto chain

/*
 * Object.create(object) creates an object with a prototype of the
 * passed in object, so it can be used to create a new link in the prototype chain 
*/
window.Incarnation.prototype = Object.create(window.Ability.prototype);
/*
 * If we didn't reset the prototype's constructor
 * attribute, it would look like any Incarnation objects
 * were constructed with an Ability constructor
 */
window.Incarnation.prototype.constructor = window.Incarnation;

// now that window.Incarnation.prototype is established, we can start in on customizing it
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.Incarnation.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);

	// Return a code string that will create a new instance
	// of Incarnation with our current data.
	return JSON.reviveWrapper(
		'new window.Incarnation($ReviveData$)',
		data
	);
};
window.Incarnation.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Incarnation(
		this
	);
};

window.Entity = function Entity(config){
	if (config.hasOwnProperty('associatedDomains')) {
		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{
		this.name = config.name;
	
		/**
		An array of strings representing domains of thought, emotion, imagination, and creativity associated with this Entity.  e.g. Foxfire entity associated with ["whimsy","illusion","seduction","manipulation","domination"]
		*/
		this.associatedDomains = [];
	
		/**
		A multi-dimensional array of Incarnations learned by wielders of this Entity at a level equivalent to the index of the Incarnation array.
		e.g. [[fire blast, ice blast],[],[rock tomb]] would indicate the wielder leanrs fire blast and ice blast at level 1, and rock tomb at level 3.
		*/
		this.associatedIncarnationsByLevel = [];
	}
}// end Entity
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/

window.Entity.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
	// Return a code string that will create a new instance
	// of Entity with our current data.
	return JSON.reviveWrapper(
		'new Entity($ReviveData$)',
		data
	);
};
window.Entity.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new Entity(
		this
	);
};

// Character object definition
window.Character = function Character(config){
	if (config.hasOwnProperty('attributes')) {
		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{
		this.id = config.id;
		this.name = config.name;
		this.gender = "";
		this.level = 10;
	
		// simple object map of categorical descriptor arrays,
		// e.g. descriptors.body = ["fur","curvacious"]
		this.descriptors = {
			body : {
			 size : "average",
			 hair : [],
			 appendages : {
				arms: {
					name : "arms"
				},
				hands : {
				 name : "hands"	
				}
			 }
			}
		}
	
		// attribute scores reflect the character's capabilities.
		// we'll use Pathfinder style scores, where 10 is sort of neutral
		// and any modifier needed is calculated as (score-10)/2
		this.attributes = {
			"charisma":10,
			"intelligence":10,
			"wisdom":10,
			"strength":10,
			"dexterity":10,
			"constitution":10
		}
		
		// just like Pathfinder saving throws, these represent a character's
		// defenses against various effects
		this.saves = {
			"fortitude" : 5,
			"reflex" : 5,
			"will" : 5
		}
		
		this.ac = {
			"armored" : 10,
			"touch" : 10
		}
	
		// basic stats, representing character vitality as resources.
		// In the absence of clear classes, went with ~ avg d10s for level 10
		// TODO: at least some of these and other consumeable resources should show in a HUD drawer
		this.stats = {
			"hp":50,
			"maxHP":50,
			"mp":50,
			"maxMP":50,
			// standard jRPG stuff; I'm thinking these will be used as modifiers in dmg formulae, and will be modified by inherent attributes plus equipment
			"atk":this.attributes["strength"],
			"def":this.attributes["constitution"],
			"pwr":this.getMagicAttributeScore(),
			"res":this.getMagicAttributeScore()
		}
		
		// a character's incarnations is an object-map of 'magic' ability names to Incarnation objects that define their effects/cost etc. The available incarnations are based
		// on inherent Entity, or that have been learned by the human
		this.incarnations = {};
		
		// a character's Entity is their inherent set of talents re: Incarnation.  Only the human can learn Incarnations from any Entity.
		this.entity = new window.Entity({name:"unset"});
	
		this.abilities = {
			"attack" : new window.Ability({id:"attack",name:"Attack"}),
			"defend" : new window.Ability({id:"defend",name:"Defend"}),
			"run" : new window.Ability({id:"run",name:"Run"}) 
		}
		this.abilities["defend"].targetType = window.Ability.TargetTypesEnum.singleAlly;
		this.abilities["run"].targetType = window.Ability.TargetTypesEnum.allAllies;

		// todo: should boilerplate functions attached to abilities, which will have to be own properties as they are subject to change from one instance to the next, somehow be on the prototype?  Maybe something like each instance has this.abl["attack"].calcDmg = this.prototype.defaultCalcDmg?
		this.abilities["attack"].calcDmg = function(sourceCharacter,targetCharacter){
			// favor the STR since the attacker is the leading participant
			// todo: yeesh, balance.  I've mixed inspiration from D&D and jRPGs in the stat blocks, and it's starting to shoooow.  Well anyway, CON is a fair stand-in for a DQ style DEF stat.
			// todo: atk is essentially useless against Puck b/c he has 500 HP and will be taking 5 damage from someone with average STR simply because his CON is average.  Recall that our STR etc. atrributes are based on D&D numbers, and D&D does NOT use same for determining base damage (only modifier).  Base damage D&D-style is a whole other thing I don't wanna get into for this demo.  For demo porpoises, I'd say fudge factors of 2 for STR and 0.25 for CON should be okay.  That way we're looking at 17-ish damage to Puck and 13-ish from him. 
			/*
			return sourceCharacter.attributes["strength"]*2 - targetCharacter.attributes["constitution"]/4;
			*/
			return sourceCharacter.stats["atk"]*2 - targetCharacter.stats["def"]/4 + Math.random()*10;
		};
		this.abilities["attack"].effect = function(sourceCharacter,targetCharacter){
			this.dmg = this.calcDmg(sourceCharacter,targetCharacter);
			console.log(this.dmg+" dealt by Attack to "+targetCharacter.name);
			// todo: AC? Any other miss chance?
			targetCharacter.stats.hp -= this.dmg; // what's multithreading, anyway? lol
			// possible player death processing
			if(targetCharacter.stats.hp <= 0){
				console.log("Attack killed "+targetCharacter.name);
				targetCharacter.living = false;
			}
		};
		this.abilities["attack"].generateFlavorText = function(sourceCharacter,targetCharacter){
			// todo: clearing cached dmg after it is read to flavor text? 
				return sourceCharacter.name+" strikes "+targetCharacter.name+" a mighty blow, dealing "+this.dmg+" damages!";
		};
		this.abilities["defend"].effect = function(sourceCharacter,targetCharacter){
			/*
			TODO: obviously this is borken af, but since Defend is traditionally useless and this is a demo, I like the irony of making it an OP move.  A better impl would be a status buff like Defended or similar that can only be added once instead of stacking endlessly.
			*/
			targetCharacter.stats["def"] += sourceCharacter.stats["def"];
		};
		this.abilities["defend"].generateFlavorText = function(sourceCharacter,targetCharacter){
			return sourceCharacter.name+" hops in front of "+targetCharacter.name+", valiantly using "+sourceCharacter.getPronoun_gen()+" own flesh to protect "+targetCharacter.getPronoun_obj()+"!";	
		};
		this.abilities["run"].generateFlavorText = function(playerParty){
			console.log("run::generateFlavorText -- The player party consists of "+playerParty);
			var flavorText = "";
			for(let i=0;i<playerParty.length;i++){
				if(i<playerParty.length-1){
					flavorText += playerParty[i].name+", ";
				}else{
					flavorText += "and "+playerParty[i].name;
				}
			}
			return flavorText+" bravely attempt to turn tail and flee, but they cannot escape!";
		};
	
		// affinities will be a simple String character name key -> integer affinity value mapping
		// that reflects how a given character feels about this character.
		// 0 is defined as totally neutral, negative values are bad and
		// positive values are good.  
		this.affinities = new Map();
		
		// a character's inventory reflects the items in the world that it is
		// currently carrying and can access.
		this.inventory = [];
		
		// a character's equipment represents weapons, armor, etc. that they are actively wearing
		this.equipment = [];
		
		// combat status effects; these are temporary and only relevant to combat
		this.statusEffects = [];
		
		/**
		Boolean flag indicating whether or not the character is alive for the purposes of combat
		*/
		this.living = true;
		
		// arbitrary PoT bitfield used to raise/lower various combat-related flags for this Character
		this.combatFlags = 0;
		
		// a simple array of keyword/phrases that indicate behavior mod in certain contexts, e.g. targetCharacter.name+"_is_digger_good"
		// to indicate that targetCharacter is as good as mole, wombats, and
		// other simple lovely creatures that happily burrow and build all their
		// lives, peaceful, passionate, and productive.
		this.inductive_bias = [];
	
	}// end new instance ctor
}// end Character class def

// Character class prototype def

window.Character.prototype.getPronoun_gen = function(){
		if(this.gender==="female"){
			return "her";
		}
		else if(this.gender==="male"){
			return "his";
		}
		else{
			return "their";
		}
	}
	window.Character.prototype.getPronoun_nom = function(){
		if(this.gender==="female"){
			return "she";
		}
		else if(this.gender==="male"){
			return "he";
		}
		else{
			return "they";	
		}
	}
	window.Character.prototype.getPronoun_obj = function(){
		if(this.gender==="female"){
			return "her";
		}
		else if(this.gender==="male"){
			return "him";
		}
		else{
			return "them";	
		}
	}
	window.Character.prototype.getMagicAttributeScore = function(){
		if(this.attributes["charisma"] >= this.attributes["intelligence"]){
			return this.attributes["charisma"];	
		}else{
			return this.attributes["intelligence"];	
		}
	}
	/**
	Check whether the resource stat pools are in sufficient supply to feed a given ability
	*/
	window.Character.prototype.canAffordCost = function(ability){
		for(let costElement in ability.cost){
			if(this.stats[costElement] < ability.cost[costElement]){
				// found a cost that cannot be satisfied, so return false
				return false;
			}
		}
		
		// if we made it here without hitting any costs we couldn't cover
		// we're good!
		return true;
	}

/**
	Adds a unique inductive bias string to the inductive bias array
	@param bias the bias to add; if it is already present, nothing happens
	*/
	window.Character.prototype.addUniqueInductiveBias = function(bias){
		if(!this.inductive_bias.includes(bias)){
			this.inductive_bias.push(bias);
		}
	}
	
	// todo: can a Map retrieve values using non-primitive keys (e.g. Character object)?
	window.Character.prototype.updateAffinity = function(characterObject,modifier){
		if(this.affinities.has(characterObject)){
this.affinities.set(characterObject,this.affinities.get(characterObject)+modifier);	
		}
		else{
			this.affinities.set(characterObject,modifier);
		}
	}
	
	/**
	Makes the character act autonomously according to its role
	@param combat: the current combat context
	@param role: could be as simple as player or enemy, but could be configurable to something like player:assist if a guided auto-battle system gets implemented someday
	*/
	window.Character.prototype.runAI = function(combat,role){
			console.log("AI behavior unset");
	}

// Character class static members
window.Character.CombatFlags = Object.freeze (
		{ 
			FLAG_SKIP_TURN: 1,
			FLAG_WONDER_WALLED: 2
		});

// Character class prototype members
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.Character.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		console.log("in toJson for "+this.name+", cloning "+propertyName);
		data[propertyName] = clone(this[propertyName]);
	}, this);
	// Return a code string that will create a new instance
	// of Character with our current data.
	return JSON.reviveWrapper(
		'new window.Character($ReviveData$)',
		data
	);
};
window.Character.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Character(
		this
	);
};

State.variables.playerCount = 0;
// Player object definition; should not need to be a story variable since it will only be defined once, later on in the characters dict (no multiplayer in the demo)
window.Player = function Player(config){
	// todo: call() 'inheritance' apparently does not attach the window.Character.prototype to window.Player -- see Object.create()
	// inherit from Character
	window.Character.call(this,config);
	
	// the player can remain in full cold for 25 room moves
	// before becoming hypothermic
	this.cold_max_count = Infinity; // this was a dumb idea for the demo
	
	// the count of turns a player has been out in the cold
	this.cold_count = 0;
	
	// human dies of hypothermia
	this.afflication_hypothermia = "hypothermia";
	
	// an array of string status ailments the player might have
	this.afflictions = [];
	
	// an array of string titles the player may obtain for outstanding deeds
	this.titles = [];
	
	
}

// todo: I'm sure this is wretched practice somehow, but it works?
// One obvious problem with this approach is that mods to Player's new prototype (which refs that of Character) would be inherited by anyone inheriting from Character after this code has run and those mods have been performed, which would be unexpected.
//window.Player.prototype = window.Character.prototype;

// establish window.Player.prototype as a proto link extending the Character proto chain

/*
 * Object.create(object) creates an object with a prototype of the
 * passed in object, so it can be used to create a new link in the prototype chain
 * for window.Player if the created object is assigned to window.Player's prototype property. 
*/
window.Player.prototype = Object.create(window.Character.prototype);
/*
 * If we didn't reset the prototype's constructor
 * attribute, it would look like any Player objects
 * were constructed with a Character constructor
 */
window.Player.prototype.constructor = window.Player;

// now that window.Player.prototype is established, we can start in on customizing it

/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.Player.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
	// Return a code string that will create a new instance
	// of Player with our current data.
	return JSON.reviveWrapper(
		'new window.Player($ReviveData$)',
		data
	);
};
window.Player.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Player(
		this
	);
};


/**
Combat object takes two arrays of Character objects, the player's
party and the enemy's party.
@param config: either an existing Combat object to be used with a copy-constructor or an object sack with parameterized fields playerParty Character array, enemyParty Character array, and destPassageName String (passage to which player should be returned after combat).
*/
window.Combat = function Combat(config){
	if (config.hasOwnProperty('playerTurnState')) {
		// here we were given an old instance of Combat to cc with

		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);

	}// end if copy ctor
	else{
		// here we're creating a new instance of Combat from a config property bag

		// parameterized properties
		this.playerParty = config.playerParty;
		console.log("in Combat ctor, playerParty[0].name says "+this.playerParty[0].name);
		this.enemyParty = config.enemyParty;
		this.destPassageName = config.destPassageName;

		// metadata about what state the player's turn is in.  This is necessary to help route the UI around the various actions a human player will need to input
		this.playerTurnState = window.Combat.PlayerTurnState.selectAbility;
		this.enemyTurnState = window.Combat.EnemyTurnState.runAI;
		this.combatResult = window.Combat.CombatResultEnum.pending;
		
		// tracks the currently selected player ability
		this.currentSelectedAbility = new window.Ability({id:"unset",name:"unset"});
		
		// tracks the turn as either player or enemy group
		this.turnGroup = "player";
		
		// tracks the actual character id whose turn it is
		this.turnOwner = "player";
		
		// tracks the currently selected ability for the current turn owner
		this.abilityName = "";
		
		// tracks the target of the current ability
		this.currentTargetCharacter = new window.Character({id:"unset",name:"unset"});
		
		// the text feedback to the user re: the state of combat
		this.combatLogContent = "What will "+State.variables.characters[this.turnOwner].name+" do?";
	}// end if new instance w/ prop bag

	/**
	Creates and returns a primitve (JSON serializable) JS object that contains the current
	value at each of this instance's fields, with the field name as the key paired with the
	current value.  The ctor(dataBundle) uses this data bundle to inflate an object from JSON,
	which is crucial for restoring state after a game is loaded.
	*/
	//this.getData = function(){
	//	var dataBundle = {}
		// I've never actually looped through attrs of a complex object before... does this work? UPDATE: apparently maybe, though everything showed undefined for some reason
		// UPDATE2: ah, the undefined was because I was using dot notation without the correct literal symbol -- that case needs bracket notation, it seems.  JS is bonkers, man.
	//	for(var attr in this){
	//		console.log(""+attr+":"+this[attr]);
	//	}
		/* manual approach; shouldn't be necessary since hasOwnProperty() is a thing
			"playerTurnState" : this.playerTurnState,
			"enemyTurnState" : this.enemyTurnState,
			"playerParty" : this.playerParty,
			"enemyParty" : this.enemyParty,
			"destPassageName" : this.destPassageName;
			"combatResult" : this.combatResult,
			"currentSelectedAbility" : this.currentSelectedAbility,
			"turnGroup" : this.turnGroup,
			"turnOwner" : this.turnOwner,
			"abilityName" : this.abilityName,
			"currentTargetCharacter" : this.currentTargetCharacter,
			"combatLogContent" : this.combatLogContent
		
	//}
	}// end if copy is not defined
	else{
		*/
		// restore from saved data bundle case
		/* manual approach, might not be necessary unless a deep copy is needed
		this.playerTurnState = dataBundle["playerTurnState"];
		this.enemyTurnState =	dataBundle["enemyTurnState"];
		this.playerParty = dataBundle["playerParty"];
		this.enemyParty = dataBundle["enemyParty"];
		this.destPassageName = dataBundle["destPassageName"];
		this.combatResult = dataBundle["combatResult"];
		this.currentSelectedAbility = dataBundle["currentSelectedAbility"];
		this.turnGroup = dataBundle["turnGroup"];
		this.turnOwner = dataBundle["turnOwner"];
		this.abilityName = dataBundle["abilityName"];
		this.currentTargetCharacter = dataBundle["currentTargetCharacter"];
		this.combatLogContent = dataBundle["combatLogContent"]; 
		*/
		/*
		Object.assign(this,copy);

	}
	*/
	
	
}// end Combat instance def

// Combat static properties - these do not need an instance of Combat at all
window.Combat.PlayerTurnState = Object.freeze (
		{ 
			selectTarget: 1, 
			selectAbility: 2,
			displayResults: 3,
			selectEnemyTarget: 4,
			selectAllyTarget: 5
		});
window.Combat.EnemyTurnState = Object.freeze (
		{ 
			runAI: 1, 
			displayResults: 2
		});
window.Combat.CombatResultEnum = Object.freeze (
		{ 
			pending: 0,
			playerVictory: 1, 
			enemyVictory: 2
		});

/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
/*
window.Combat.prototype.toJSON = function () {
	// Return a code string that will create a new instance
	// of Combat with our current data.
	return JSON.reviveWrapper(String.format(
		'new window.Combat({0},{1},{2})',
		JSON.stringify(this.playerParty),
		JSON.stringify(this.enemyParty),
		JSON.stringify(this.destPassageName)
		//todo: need to be able to restore entire complex object state
		// so we either need:
		// 1. to use the $ReviveData$ var and pass it a simple anon object with
		// key/value pairs for each field, and then write a ctor for each complex object
		// that expects such a data bundle to inflate itself from
		// 2. stringify each complex object field and write a ctor that takes all fields
		// as params (not recommended)
		// 2. to use a copy ctor and then teach JSON how to stringify an entire complex object
		// which is basically what I think toJSON() would normally be doing... I dunno, I don't particularly wanna go against the Sugarcube docs' recommendation to use their JSON.reviveWrapper() method, which sort of combines de/serialization oddly into one shot.  Keeping with that approach, the thing to do is #1, and indeed the docs' $pc_getData() function sounds like it would be doing the thing from #1.
	));
};
window.Combat.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Combat(
		this.playerParty,
		this.enemyParty,
		this.destPassageName
	);
};
*/
// Combat prototype methods - these have common behavior throughout all Combat instances, but depend on a given instance which is passed in implicitly based on calling object
window.Combat.prototype.randoCombatantExcept = function(exceptCharacter){
		var combatants = this.enemyParty.concat(this.playerParty);
		var eligibleCombatants = combatants.filter(combatant => combatant.id != exceptCharacter.id);
		var unluckyIndex = Math.floor(Math.random() * eligibleCombatants.length);
		return eligibleCombatants[unluckyIndex];
		
	}
	/**
	Concat the enemy and player party arrays, and return result
	*/
	window.Combat.prototype.getAllCombatants = function(){
		return this.enemyParty.concat(this.playerParty);
	}
	
	/**
	Handle upkeep related to a new round beginning (i.e. top of the round to ye!)
	*/
	window.Combat.prototype.processRoundTop = function(){
	// tick down status effects
	for(let enemyChar of this.enemyParty){
		var enemyCharacter = State.variables.characters[enemyChar.id];
			for(let effect of enemyCharacter.statusEffects){
				if(enemyCharacter.living){
					// process top of stateffects with variable or triggered effects per round
					if(effect.id === "terror"){
						// terror's effect will roll percentage, with 35% to skip this turn
						if(effect.effect()){
							enemyCharacter.combatFlags |= window.Character.CombatFlags.FLAG_SKIP_TURN;	
						}
					}
					else if(effect.id === "poison"){
						enemyCharacter.stats["hp"] -= enemyCharacter.stats["maxHP"]*0.1; 	
					}
					else if(effect.id === "regen"){
						window.statusEffectsDict["regen"].effect(enemyCharacter);	
					}
					
					
					effect.tickDown();
					if(effect.ticks <= 0){
						// reverse the effect now that it is over
						effect.reverseEffect(enemyCharacter);	
						// reset the ticks count to duration in case we
						// want to re-use this statuseffect instance
						effect.ticks = effect.duration;
						// remove the status effect from the character
						window.removeStatusEffect(enemyCharacter,effect);
					}
				}else{
					// reverse the effect now that char is dead
					effect.reverseEffect(enemyCharacter);	
					// reset the ticks count to duration in case we
					// want to re-use this statuseffect instance
					effect.ticks = effect.duration;
					// remove the status effect from the character
					window.removeStatusEffect(enemyCharacter,effect);
				}
			}
	}
	for(let playerChar of this.playerParty){
		var playerCharacter = State.variables.characters[playerChar.id];
			for(let effect of playerCharacter.statusEffects){
				if(playerCharacter.living){
					// process top of stateffects with variable effects per round
					if(effect.id === "terror"){
						// terror's effect will roll percentage, with 35% to skip this turn
						if(effect.effect()){
							playerCharacter.combatFlags |= window.Character.CombatFlags.FLAG_SKIP_TURN;	
						}
					}
					else if(effect.id === "regen"){
						window.statusEffectsDict["regen"].effect(playerCharacter);	
					}
					
					effect.tickDown();
					if(effect.ticks <= 0){
						// reverse the effect now that it is over
						effect.reverseEffect(playerCharacter);	
						// reset the ticks count to duration in case we
						// want to re-use this statuseffect instance
						effect.ticks = effect.duration;
						// remove the status effect from the character
						window.removeStatusEffect(playerCharacter,effect);
					}
				}else{
					// reverse the effect now that character is dead
					effect.reverseEffect(playerCharacter);	
					// reset the ticks count to duration in case we
					// want to re-use this statuseffect instance
					effect.ticks = effect.duration;
					// remove the status effect from the character
					window.removeStatusEffect(playerCharacter,effect);
				}
			}
	}
 }// end processRoundTop fn
	
	/**
	Process the bottom of a combat round.  
	*/
	window.Combat.prototype.processRoundBottom = function(){
		var dedEnemies = 0;
		var dedPlayers = 0;
		for(let enemyChar of this.enemyParty){
			var enemyCharacter = State.variables.characters[enemyChar.id];
			for(let effect of enemyCharacter.statusEffects){
				// process bottom of stateffects with variable effects per round
				if(effect.id === "terror"){
					// clear the FLAG_SKIP_TURN flag
		enemyCharacter.combatFlags &= ~window.Character.CombatFlags.FLAG_SKIP_TURN;
				}
			}
			
			// check for death
			if(enemyCharacter.stats.hp <= 0){
				dedEnemies++;	
			}
		}
		for(let playerChar of this.playerParty){
			// extract Character object from $characters
			var playerCharacter = State.variables.characters[playerChar.id];
			for(let effect of playerCharacter.statusEffects){
				// process bottom of stateffects with variable effects per round
				if(effect.id === "terror"){
					// clear the FLAG_SKIP_TURN flag
		playerCharacter.combatFlags &= ~window.Character.CombatFlags.FLAG_SKIP_TURN;
				}
			}
			
			// check for death
			if(playerCharacter.stats.hp <= 0){
				dedPlayers++;	
			}
		}
		
		// check victory conditions -- if one is met, we do not need another turn so return false.  Else, combat continues so we return true.
		// todo: need a way to clear conditions and/or reset stats as desired at end of combat
		console.log("Dead players: "+dedPlayers+", dead enemies: "+dedEnemies);
		if(dedEnemies >= this.enemyParty.length){
			this.combatResult = window.Combat.CombatResultEnum.playerVictory;
			return false;	
		}else if(dedPlayers >= this.playerParty.length){
			this.combatResult = window.Combat.CombatResultEnum.enemyVictory;
			return false;	
		}else{
			return true;	
		}
		
	}// end processRoundBottom()
window.Combat.prototype.toJSON = function() {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
    return JSON.reviveWrapper('new window.Combat($ReviveData$)',data);
};
window.Combat.prototype.clone = function() {
    // Return a new instance containing our current data.
    return new window.Combat(
        this
    );
};

State.variables.combatArena = undefined;

window.Room = function Room(config){
	if(config.hasOwnProperty('field_mods')){
		Object.keys(config).forEach(function(propertyName){
			this[propertyName] = clone(config[propertyName]);
		},this);
	}// end cc
	else{
		// array of field mods that have occurred in this room
		this.field_mods = [];
	}// end new instance ctor
}

window.Room.prototype.toJSON = function(){
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
	return JSON.reviveWrapper(
		'new window.Room($ReviveData$)',
		data
	);
};
window.Room.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Room(
		this
	);
};

/*//moved into Character object, of which Player is an instance
function Affinities(){
	this.nuvi_affinity = 0;
}

var playerAffinities = new Affinities();
*/

/**
An Item is an object that the player can use and/or equip
*/
window.Item = function Item(config){
	if(config.hasOwnProperty('description')){
		// copy the own properties automatically, for simplicity.
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{
		this.id = config.id;
		this.name = config.name;
		this.useEffect = function(){console.log("Using the "+this.name+" accomplishes little, but you do look silly.");}
		// todo: instead of having a simple one-way equip effect, we need something more structured that can be queried later, e.g. in stat recompute fn (where we want to recompute atk as STR + weapon modifier).  Something that has properties tracking the modifications to attrs or stats.
		this.equipEffect = function(){console.log("You equip the "+this.name+" and now boast an eccentric stylish look.");}
		this.description = this.name+" is uncannily nondescript -- you've already forgotten its details and you're still looking at it!";
		// todo: some sort of on-hit effect for weapons?
	}//end new instance ctor
}// end Item
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.Item.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
	// Return a code string that will create a new instance
	// of Item with our current data.
	return JSON.reviveWrapper(
		'new window.Item($ReviveData$)',
		data
	);
};
window.Item.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new window.Item(
		this
	);
};

/// begin global story state dicts ///

// Global Object mapping of prefab Characters
State.variables.characters = {
	"nuvi" : new window.Character({id:"nuvi",name:"Nuvi"}),
	"player" : new window.Player({id:"player",name:"The Human"}),
	"shimmerin" : new window.Character({id:"shimmerin",name:"Shimmerin"}),
	"sheila" : new window.Character({id:"sheila",name:"Sheila"}),
	"council" : new window.Character({id:"council",name:"Council Of Animals"}),
	"marrah" : new window.Character({id:"marrah",name:"Marrah"}),
	"drbeakman" : new window.Character({id:"drbeakman",name:"Dr. Beakman"}),
	"mooty" : new window.Character({id:"mooty",name:"Mooty Wort"}),
	"puck" : new window.Character({id:"puck",name:"Puck"})
}

// Global Object mapping of prefab StatusEffects
window.statusEffectsDict = {
	/**
	Bloodlust raises STR at the expense of all mental attributes
	*/
	"bloodlust" : new window.StatusEffect({id:"bloodlust",name:"Bloodlust",duration:3}),
	/**
	Doubt halves all confidence based attributes (STR and CHA)
	*/
	"doubt" : new window.StatusEffect({id:"doubt",name:"Doubt",duration:3}),
	/**
	Terror gives a 35% chance to do nothing but shiver in fear
	*/
	"terror" : new window.StatusEffect({id:"terror",name:"Terror",duration:5}),
	/**
	Poison inflicts 5% health dmg each turn, and helaves atk/def
	*/
	"poison" : new window.StatusEffect({id:"poison",name:"Poison",duration:3}),
	/**
	Shadow makes the affected character immune to physical dmg
	*/
	"shadow" : new window.StatusEffect({id:"shadow",name:"Shadow",duration:3}),
	/**
	Regen heals each turn
	*/
	"regen" : new window.StatusEffect({id:"regen",name:"Regen",duration:3}),
	/**
	Confuse causes the AI to 50% redirct its chosen abl at itself
	*/
	"confuse" : new window.StatusEffect({id:"confuse",name:"Confusion",duration:3}),
	/**
	Charm causes the afflicted character to be unable to target the character who charmed them with harmful abilities
	*/
	"charm" : new window.StatusEffect({id:"charm",name:"Charm",duration:3}),
	/**
	Temper doubles physical attack power for 3 turns
	*/
	"temper" : new window.StatusEffect({id:"temper",name:"Temper",duration:3}),
	/**
	Focus doubles magic attack power for 3 turns
	*/
	"focus" : new window.StatusEffect({id:"focus",name:"Focus",duration:3}),
	/**
	Third Eye quadruples magic attack power for 3 turns at the expense of halved physical attack and defense
	*/
	"third_eye" : new window.StatusEffect({id:"third_eye",name:"Third Eye",duration:3}),
	/**
	Defenseless reduces the target's defensive stats by half for 3 turns
	*/
	"defenseless" : new window.StatusEffect({id:"defenseless",name:"Defenseless",duration:3})
}

/* // room objects might be overkill since they'll be pretty different, and it really starts to fight with Twine rather than leveraging it
window.rooms = {
	"Shimmerin_Chase_Ghostly_Greeting_Chamber" : new Room(...) 	// defined here?  With all details or boilerplate that's modified later?
}
*/

/* // is this delegate inheritance?  MDN suggests that delegation proto inheritance can allow state to creep between instances somehow with common fields being changed for all instances, but I don't understand what they mean.  This works as expected.
var characters = State.variables.characters;
alert("player is "+characters["player"].name+", nuvi is "+characters["nuvi"].name+", and shimmerin is "+characters["shimmerin"].name);
*/

/**
Global dictionary object of public incarnations.  Since The Human can learn any Incarnation, all the Incarnations should be indexed here
TODO: move the inline definitions of Incarnations from within Character configs to here, and then reference this dict in said configs.
*/
window.incarnationsDict = {
	// from Splinter of Serpentarius
	"debilitate" : new window.Incarnation({id:"debilitate",name:"Debilitate"}),
	"pierce" : new window.Incarnation({id:"pierce",name:"Pierce"}),
	"toxin" : new window.Incarnation({id:"toxin",name:"Toxin"}),
	// from Splinter of Violet
	"shadowform" : new window.Incarnation({id:"shadowform",name:"Shadowform"}),
	"perfect_stillness" : new window.Incarnation({id:"perfect_stillness",name:"Perfect Stillness"}),
	"savage_sympathy" : new window.Incarnation({id:"savage_sympathy",name:"Savage Sympathy"}),
	// from Splinter of Snugg-lor
	"warmest_hug" : new window.Incarnation({id:"warmest_hug",name:"Warmest Hug"}),
	"woolly_shield" : new window.Incarnation({id:"woolly_shield",name:"Woolly Shield"}),
	"maenad_frenzy" : new window.Incarnation({id:"maenad_frenzy",name:"Maenad Frenzy"}),
}

window.itemsDict = {
	"wicked_axe" : new window.Item({id:"wicked_axe",name:"Wickedly Curved Axe"}),
	"cold_mace" : new window.Item({id:"cold_mace",name:"Inexplicably Cold Mace"}),
	"sawtooth_star_dagger" : new window.Item({id:"sawtooth_star_dagger",name:"Starlight Sawtooth Dagger"})
}

/// end global story state dicts ///
	
// establish Player party
State.variables.party = [State.variables.characters["player"]];

/*// moved to Character object, from which Player inherits 
// establish Player inventory
State.variables.inventory = [];
*/

// inductive biases characters may have toward the Player

// fuzzy biases TODO: make these constant with Object.freeze()
window.inductive_bias_digger_good = "digger_good";
window.inductive_bias_clever = "clever";
window.inductive_bias_animal_handler = "animal_handler";
window.inductive_bias_crush = "crush";

// unfortunate biases
window.inductive_bias_liar = "liar";
window.inductive_bias_manipulative = "manipulative";
window.inductive_bias_lacks_confidence = "lacks_confidence";
window.inductive_bias_humble = "humble";
window.inductive_bias_knows_limitations = "knows_limitations";

// titles the player can have
window.title_wombuddy = "wombuddy";

/// begin Shimmerin acq///
window.field_mod_anicemole_burrowed = "anicemole_burrowed";

window.AnIceMole = function AnIceMole(config){
	if(config.hasOwnProperty('ice_mole_room')){
		Object.keys(config).forEach(function (propertyName) {
			// clone() is a sugarcube built-in that returns a deep copy of the given object
			this[propertyName] = clone(config[propertyName]);
		}, this);
	}// end cc
	else{
		this.path_index = 0;
		// the path an ice mole can take
		this.ice_mole_path = ["Shimmerin_Chase_Frozen_Stair","Shimmerin_Chase_Diamond_Throneroom","Shimmerin_Chase_Treasure_Of_Stillness","Shimmerin_Chase_Crystal_Gardens"];
		// the ice mole's current position
		this.ice_mole_room = this.ice_mole_path[this.path_index];
		
		// flag indicating that the ice mole is present in the room when the player enters and there needs to be text detailing how he burrows away
		//this.ice_mole_burrow_flag = false;
	}// end new instance ctor
}// and AnIceMole

// AnIceMole class prototype def
/**
	Advances anicemole along his path
	*/
	window.AnIceMole.prototype.advance = function(){
			// advance the path index, accounting for wraparound
		  this.path_index++;
			if(this.path_index == this.ice_mole_path.length){
				this.path_index = 0;
			}
			
			// set the current room to the room along the path
			// at the new index
			this.ice_mole_room = this.ice_mole_path[this.path_index];
		  //alert("path index is "+this.path_index+", which resolves to "+this.ice_mole_path[this.path_index]);
	} // end advance function
	/**
	Retreats anicemole along his path
	*/
	window.AnIceMole.prototype.retreat = function(){
			// retreat the path index, accounting for wraparound
		  this.path_index--;
			if(this.path_index == -1){
				this.path_index = this.ice_mole_path.length-1;
			}
			
			// set the current room to the room along the path
			// at the new index
			this.ice_mole_room = this.ice_mole_path[this.path_index];
		  //alert("path index is "+this.path_index+", which resolves to "+this.ice_mole_path[this.path_index]);
	} // end retreat function
	
	/**
	Anicemole burrows hastily away!  This will modify the current room and also advance the mole.
	*/
	window.AnIceMole.prototype.burrow = function(){
		// add the current passage to list of rooms the mole has burrowed through.  This isn't quite ideal since not all passages are a discrete room, but in the case of the shimmerin maze where the mole will be, they are.  Better might be to check the passage tags for 'room' before making this mod?  Of course, the mole shouldn't be burrowing outside a room passage anyway, so...
		//State.variables.mole_burrowed_array.push(passage());
		
		// add anicmole burrowed to the mods array for the current room
		var currentModsArray = State.variables.field_mods_map.get(passage());
		
		// need to check for null return of field mods at given passage and init currentModsArray to an empty new array in that case
		if (typeof currentModsArray == 'undefined'){
			currentModsArray = [window.field_mod_anicemole_burrowed];
			State.variables.field_mods_map.set(passage(),currentModsArray);	
		}else if(!currentModsArray.includes(window.field_mod_anicemole_burrowed)){

						 // field mods exist for this passage, but they do not yet include anicemole's burrowing.  Add burrowing to it.
						 currentModsArray.push(window.field_mod_anicemole_burrowed);
		
	 }
		
		
		this.advance();
	}
/**
It is necessary to implement toJSON and clone for all complex objects to facilitate
JSON de/serialization
*/
window.AnIceMole.prototype.toJSON = function () {
	// NOTE: Do not use `this` directly for $ReviveData$ or you'll trigger
	// out of control recursion and SO.  Make a copy of the own
	// properties instead.
	var data = {};
	Object.keys(this).forEach(function (propertyName) {
		data[propertyName] = clone(this[propertyName]);
	}, this);
	// Return a code string that will create a new instance
	// of AnIceMole with our current data.
	return JSON.reviveWrapper(
		'new AnIceMole($ReviveData$)',
		data
		);
};
window.AnIceMole.prototype.clone = function () {
	// Return a new instance containing our current data.
	return new AnIceMole(this);
};

// grant access to anicemole instance in the story
State.variables.anicemole = new AnIceMole({});

/// end Shimmerin acq ///

/// begin wombat test quest ///

// number of times the player has attempted the wombats' wombuddy test 
State.variables.wombuddy_trials = 0;
State.variables.wombuddy_score = 0;

/// end wombat test quest ///

/**
A map of room names to arrays of modification descriptor strings that can be used to look up rooms that have runtime modification, e.g. anicemole burrowed and changed something in rooms x, y, and z so if room z checks this map's return value array for 'anicemole_burrowed' it will return true and know that burrowing mods need to be handled.  Interested rooms can check at the top of their passage with field_mods_map.get(passage())
*/
State.variables.field_mods_map = new Map();

// todo: at the top of every room in the shimmerin maze, the mole will move his position to the room at the next index in his path.  If the mole position matches the current passage title, the mole description will be part of the passage and the mole will burrow to escape the player.  The burrow flag will be raised, indicating that at the top of the next passage we do not need to auto-move the mole again.  Once the burrow flag is read as true, it will be lowered.  If the mole burrows away in the Treasure of Stillness room, the Tiny Tiara will be freed for acq.

/// end Shimmerin ///

/*
Config.constructor.prototype.combat = function Combat(){
	this.name = "";
	this.actors = {};
	this.getName = function(){
		return this.name;	
	}
}
*/

/**
Main program init function.  Configures and fleshes out global objects
*/
function init(){
	
	//items
	
	var wickedlyCurvedAxe = window.itemsDict["wicked_axe"];
	wickedlyCurvedAxe.equipEffect = function(targetChar){
		targetChar.stats["atk"] += 20;
	}	
	wickedlyCurvedAxe.description = "This axe is a solid piece of metal as black as the darkest corner of the abyss, so sharp that light itself appears to silently die upon its edge.  The Lumpkins have a prohecy that \'a shard of shadow will split the fundaments of the world and bring all that they love crashing down upon them\'... it's probably nothing.";
	// todo: bleed status effect on-hit?
	var coldMace = window.itemsDict["cold_mace"];
	coldMace.equipEffect = function(targetChar){
		targetChar.stats["atk"] += 5;
		targetChar.attributes["charisma"] -= 10;
		targetChar.attributes["intelligence"] += 10;
		// todo: recompute the pwr/res based on new mental stats
		targetChar.stats.mp += 10;
	}
	coldMace.description = "The very chill that grips the heart of a snowstorm flashes through you as you gingerly touch the haft of this hefty mace.  You feel your concern for other living things dull notably, as an insidiously gentle numbness flows through your soul; in a moment, everything is a simple equation as clear and coldly beautiful as the corpse of a flower entombed within ice.  Your breath mists despite the temperate weather.";
	var sawtoothDagger = window.itemsDict["sawtooth_star_dagger"];
	sawtoothDagger.equipEffect = function(targetChar){
		targetChar.stats["atk"] = 0;
		targetChar.attributes["charisma"] += 10;
		targetChar.attributes["intelligence"] += 10;
		targetChar.attributes["wisdom"] += 10;
		// todo: recompute the pwr/res based on new mental stats
		targetChar.stats.mp += 20;
	}
	sawtoothDagger.description = "Starlight glitters from within this jagged dagger, as if it is a little fragment of a fallen star.  Darkness practically flees from its surface, and in the instant before light fills the void you think you catch a glimpse of something staring back at you from the other side of an unfathomable gulf... and winking.";
	
	// status effects
	/**
	Defenseless halves a character's defensive attributes 
	*/
	// todo: I keep wanting to do mag def and phys def etc. stat changes -- add jRPG standard stats which are informed by D&D attributes, maybe?
	var defenselessStatusEffect = window.statusEffectsDict["defenseless"];
	defenselessStatusEffect.buffity = "bluffins";
	defenselessStatusEffect.descriptors.push("debuff","defense");
	defenselessStatusEffect.effect = function(targetChar){
		targetChar.stats["def"] *= 0.5;
		targetChar.stats["res"] *= 0.5;
	}
	defenselessStatusEffect.reverseEffect = function(targetChar){
		// todo: this should get a recompute call that sources attrs and equipment rather than doing a direct reversal like this; otherwise defenseless + any defense buff + ~defenseless -> gt intended buff increase to defenses
		targetChar.stats["def"] *= 2;
		targetChar.stats["res"] *= 2;
	}
	
	/**
	Temper provides a simple ATK*2 for 3 turns
	*/
	var temperStatusEffect = window.statusEffectsDict["temper"];
	temperStatusEffect.buffity = "buffins";
	temperStatusEffect.descriptors.push("buff","offense");
	temperStatusEffect.effect = function(targetChar){
		targetChar.stats["atk"] *= 2;
	}
	temperStatusEffect.reverseEffect = function(targetChar){
		targetChar.stats["atk"] *= 0.5;
	}
	
	/**
	Focus provides a simple PWR*2 for 3 turns
	*/
	var focusStatusEffect = window.statusEffectsDict["focus"];
	focusStatusEffect.buffity = "buffins";
	focusStatusEffect.descriptors.push("buff","offense");
	focusStatusEffect.effect = function(targetChar){
		targetChar.stats["pwr"] *= 2;
	}
	focusStatusEffect.reverseEffect = function(targetChar){
		targetChar.stats["pwr"] *= 0.5;
	}
	
	/**
	Third Eye provides a PWR*4 at cost of ATK/2 and DEF/2 for 3 turns
	*/
	var thirdEyeStatusEffect = window.statusEffectsDict["third_eye"];
	thirdEyeStatusEffect.buffity = "buffins";
	thirdEyeStatusEffect.descriptors.push("buff","offense");
	thirdEyeStatusEffect.effect = function(targetChar){
		targetChar.stats["pwr"] *= 4;
		targetChar.stats["atk"] *= 0.5;
		targetChar.stats["def"] *= 0.5;
	}
	thirdEyeStatusEffect.reverseEffect = function(targetChar){
		targetChar.stats["pwr"] *= 0.25;
		targetChar.stats["atk"] *= 2;
		targetChar.stats["def"] *= 2;
	}
	
	/**
	Regen heals a character by their RES each turn
	*/
	var regenStatusEffect = window.statusEffectsDict["regen"];
	regenStatusEffect.buffity = "buffins";
	regenStatusEffect.descriptors.push("buff","health");
	regenStatusEffect.effect = function(targetChar){
		console.log("Wounds close and gaping wounds knit themselves shut as "+targetChar.name+" regenerates "+targetChar.stats["res"]+" HP!");
		targetChar.stats["hp"] += targetChar.stats["res"];
	}
	regenStatusEffect.reverseEffect = function(targetChar){}
	
	/**
	Doubt halves a character's attributes that are driven by presence and self-confidence: STR and CHA.
	*/
	var doubtStatusEffect = window.statusEffectsDict["doubt"];
	doubtStatusEffect.buffity = "bluffins";
	doubtStatusEffect.descriptors.push("debuff","offense");
	doubtStatusEffect.effect = function(targetChar){
		/*
		targetChar.attributes["strength"] *= 0.5;
		targetChar.attributes["charisma"] *= 0.5;
		*/
		targetChar.stats["atk"] *= 0.5;
		targetChar.stats["pwr"] *= 0.5;
	}
	doubtStatusEffect.reverseEffect = function(targetChar){
		/*
		targetChar.attributes["strength"] *= 2;
		targetChar.attributes["charisma"] *= 2;
		*/
		targetChar.stats["atk"] *= 2;
		targetChar.stats["pwr"] *= 2;
	}
	
	/**
	Bloodlust quadruples STR in exchange for halving all mental attributes
	*/
	var bloodlustStatusEffect = window.statusEffectsDict["bloodlust"];
	bloodlustStatusEffect.buffity = "buffins";
	bloodlustStatusEffect.descriptors.push("buff","offense");
	bloodlustStatusEffect.effect = function(targetChar){
		/*
		targetChar.attributes["strength"] *= 4;
		targetChar.attributes["charisma"] *= 0.5;
		targetChar.attributes["intelligence"] *= 0.5;
		targetChar.attributes["wisdom"] *= 0.5;
		*/
		targetChar.stats["atk"] *= 4;
		targetChar.stats["pwr"] *= 0.5;
		targetChar.stats["res"] *= 0.5;
	}
	bloodlustStatusEffect.reverseEffect = function(targetChar){
		/*
		targetChar.attributes["strength"] *= 0.25;
		targetChar.attributes["charisma"] *= 2;
		targetChar.attributes["intelligence"] *= 2;
		targetChar.attributes["wisdom"] *= 2;
		*/
		targetChar.stats["atk"] *= 0.25;
		targetChar.stats["pwr"] *= 2;
		targetChar.stats["res"] *= 2;
		
		
	}
	
	var terrorStatusEffect = window.statusEffectsDict["terror"];
	terrorStatusEffect.buffity = "bluffins";
	terrorStatusEffect.descriptors.push("debuff","turn");
	terrorStatusEffect.effect = function(targetChar){
		// I can think of two ways for the terror rando turn skip thing to work:
		// 1. We remove the afflicted character from the relevant party array of the combat instance when terror strikes and then add them back in a round post proc
		// 2. We add a bitfield to Character that can receive abitrary PoT flags like {FLAG_SKIP_TURN = 1} and when the character's turn comes up (or elsewhere, as needed) we check this bitfield for relevant raised flags.  In the case of FLAG_SKIP_TURN, we'd need to process the randomness and decide whether or not to raise the flag in round pre proc and then lower the flag in each round post proc since the character is not necessarily terrorized each round.
		
		// raise flag
		//targetChar.combatFlags |= window.Character.CombatFlags.FLAG_SKIP_TURN; // flag needs to be raised in round pre proc.  The pre proc block should check for this status effect and then call its effect(), which will return true if some status-effect-specific percentage range is hit.
		
		// 35% chance
		return window.rollPercentage() <= 35;
	}
	terrorStatusEffect.reverseEffect = function(targetChar){}
	
	/**
	Poison deals dmg each turn and halves atk/def stats
	*/
	var poisonStatusEffect = window.statusEffectsDict["poison"];
	poisonStatusEffect.buffity = "bluffins";
	poisonStatusEffect.descriptors.push("debuff","health");
	poisonStatusEffect.effect = function(targetChar){
		targetChar.stats["atk"] *= 0.5;
		targetChar.stats["def"] *= 0.5;
	}
	poisonStatusEffect.reverseEffect = function(targetChar){
		targetChar.stats["atk"] *= 2;
		targetChar.stats["def"] *= 2;
	}
	
	var shadowStatusEffect = window.statusEffectsDict["shadow"];
	shadowStatusEffect.buffity = "buffins";
	shadowStatusEffect.descriptors.push("buff","defense");
	shadowStatusEffect.effect = function(targetChar){
		this.cachedDef = targetChar.stats["def"];
		targetChar.stats["def"] = Infinity;
	}
	shadowStatusEffect.reverseEffect = function(targetChar){
		targetChar.stats["def"] = this.cachedDef;
	}
	
	var confuseStatusEffect = window.statusEffectsDict["confuse"];
	confuseStatusEffect.buffity = "bluffins";
	confuseStatusEffect.descriptors.push("debuff","turn","ai","abilities");
	confuseStatusEffect.effect = function(targetChar){
		return window.rollPercentage() > 50;
	}
	confuseStatusEffect.reverseEffect = function(targetChar){}
	
	var charmStatusEffect = window.statusEffectsDict["charm"];
	charmStatusEffect.buffity = "bluffins";
	charmStatusEffect.descriptors.push("debuff","turn","ai","targeting");
	charmStatusEffect.effect = function(sourceChar,targetChar){
		// set the id of the forbidden target for this effect instance
		this.sourceCharacterId = sourceChar.id;
	}
	charmStatusEffect.reverseEffect = function(targetChar){
		this.sourceCharacterId = undefined;
	}
	
	// public incarnations
	
	// from Splinter of Serpentarius
	/**
	Debilitate lowers all defensive attributes of the target, and inflicts currHp*0.1 dmg
	*/
	var debilitate = window.incarnationsDict["debilitate"];
	debilitate.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	debilitate.cost = {"mp":25};
	debilitate.calcDmg = function(sourceChar,targetChar){
		return targetChar.stats.hp*0.1;	
	}
	debilitate.effect = function(sourceChar,targetChar){
		window.addUniqueStatusEffect(targetChar,defenselessStatusEffect);	
		
		// MP cost
		this.processCost(sourceChar);
	}
	debilitate.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" narrows "+sourceChar.getPronoun_gen()+" eyes, shining with cruel malice, at "+targetChar.name+".  Space distorts mildly, constricting around and through "+targetChar.name+", and "+targetChar.getPronoun_gen()+" presence seems to diminish substantially!";	
	}
	/**
	Pierce is a physical strike for which atk bypasses def
	*/
	var pierceIncarnation = window.incarnationsDict["pierce"];
	pierceIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	pierceIncarnation.cost = {"hp":10};
	pierceIncarnation.calcDmg = function(sourceChar,targetChar){
		return sourceChar.stats["atk"]*2+Math.random()*10;		
	}
	pierceIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] -= this.dmg;
		
		// HP cost
		this.processCost(sourceChar);
	}
	pierceIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" smoothly reaches directly into "+targetChar.name+"'s soul, and just kinda... fiddles around a little.  "+targetChar.name+" does not appreciate this, emphatically, to the tune of "+this.dmg+" delicious damages!";	
	}
	
	var toxinIncarnation = window.incarnationsDict["toxin"];
	toxinIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	toxinIncarnation.cost = {"mp":15};
	toxinIncarnation.calcDmg = function(sourceChar,targetChar){
		return sourceChar.stats["pwr"]-targetChar.stats["res"];		
	}
	toxinIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] -= this.dmg;
		window.addUniqueStatusEffect(targetChar,poisonStatusEffect);
		
		// MP cost
		this.processCost(sourceChar);
	}
	toxinIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return "An aura of gleaming electric purple light, striated with the cheerily deadly greenish glow of radioactivity, surrounds "+sourceChar.name+" as "+sourceChar.getPronoun_gen()+" fevered will infects "+targetChar.name+".  The insidious infection quickly overwhelms "+targetChar.name+"'s immune system totally, dealing "+this.dmg+" damage, and promising more...";	
	}
	
	// from Splinter of Violet
	/**
	Shadowform makes the character immune to physical damage.  
	TODO: add a physical/magic damage typing system.  For now, we'll just make def infinite.
	*/
	var shadowFormIncarnation = window.incarnationsDict["shadowform"];
	shadowFormIncarnation.targetType = window.Ability.TargetTypesEnum.allAllies; // actually self-only, but this will have the same effect in the UI
	shadowFormIncarnation.cost = {"mp":30};
	shadowFormIncarnation.effect = function(sourceChar,targetChar){
		window.addUniqueStatusEffect(sourceChar,shadowStatusEffect);
		
		// MP cost
		this.processCost(sourceChar);
	}
	shadowFormIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return "Shadows dance free of their source lights, and embrace "+sourceChar.name+" warmly.  Velvet darkness spreads over "+sourceChar.getPronoun_gen()+" body, and "+sourceChar.getPronoun_nom()+" relaxes into oneness with the infinite possibilities of undefinition; "+sourceChar.getPronoun_nom()+" seems almost ethereal now.";	
	}
	
	/**
	Perfect Stillness deals mild cold damage to the wielder and massive cold damage to the target
	*/
	var perfectStillnessIncarnation = window.incarnationsDict["perfect_stillness"];
	perfectStillnessIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	// by the time the HP cost is being evaluated, the selfDmg property should have been set in effect().  Would this be bound to perfectStillnessIncarnation inside the newly inline cost object map?
	perfectStillnessIncarnation.cost = {"mp":15};//,"hp":perfectStillnessIncarnation.selfDmg};
	perfectStillnessIncarnation.calcDmg = function(sourceChar,targetChar){
		return 5*sourceChar.stats["pwr"] - targetChar.stats["res"]/4;		
	}
	perfectStillnessIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		this.selfDmg = this.calcDmg(sourceChar,sourceChar);
		targetChar.stats["hp"] -= this.dmg;
		sourceChar.stats["hp"] -= this.selfDmg/5; // todo: move to cost so that it is transparent to user via UI display of abl costs; make sure calcDmg() can peek at the dmg from that point
		
		// MP cost
		this.processCost(sourceChar);
	}
	perfectStillnessIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" extends "+sourceChar.getPronoun_gen()+" arms slowly towards "+targetChar.name+", almost as if inviting a hug.  Suddenly, a rolling torrent of absolute serenity and silence, so profoundly vaccuous that it forces all in attendance to take a step back as from an overwhelming physical force, explodes forth from "+sourceChar.getPronoun_obj()+".  Both folks are rocked by the violence of the peace, and "+targetChar.name+" is driven to "+targetChar.getPronoun_nom()+" knees by "+this.dmg+" chilling damage!";	
	}
	
	/**
	Savage Sympathy deals more damage the greater the difference between the wielder and the target's ATK, and heals the wielder
	*/
	var savageSympathyIncarnation = window.incarnationsDict["savage_sympathy"];
	savageSympathyIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	savageSympathyIncarnation.cost = {"mp":20};
	savageSympathyIncarnation.calcDmg = function(sourceChar,targetChar){
		return Math.abs(targetChar.stats["atk"] - sourceChar.stats["atk"])*2;		
	}
	savageSympathyIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] -= this.dmg;
		sourceChar.stats["hp"] += this.dmg/2;
		
		// MP cost
		this.processCost(sourceChar);
	}
	savageSympathyIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" is no fan of natural privilege.  In fact, "+sourceChar.getPronoun_nom()+" takes ecstatic pleasure in balancing the old scales, with blood if necessary.  To wit, blood from "+targetChar.name+"'s orificeses begins slowly spiraling through the air and into "+sourceChar.name+"'s snarling mouth.  This gruesome spectacle illustrates a whopping "+this.dmg+" damage!";	
	} 
	
	// from Splinter of Snugg-lor
	/**
	Warmest hug heals self and other with ATK
	*/
	var warmestHugIncarnation = window.incarnationsDict["warmest_hug"];
	warmestHugIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
	warmestHugIncarnation.cost = {"mp":20};
	warmestHugIncarnation.calcDmg = function(sourceChar,targetChar){
		return sourceChar.stats["atk"];		
	}
	warmestHugIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] += this.dmg;
		sourceChar.stats["hp"] += this.dmg;
		
		// MP cost
		this.processCost(sourceChar);
	}
	warmestHugIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" embraces "+sourceChar.getPronoun_gen()+" friend "+targetChar.name+" fondly, a soft golden glow surrounding them both.  The glow heals "+targetChar.name+" of "+this.dmg+" damage.";	
	} 
	
	/**
	Woolly Shield raises target's DEF by wielder's RES+DEF
	*/
	var woollyShieldIncarnation = window.incarnationsDict["woolly_shield"];
	woollyShieldIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
	woollyShieldIncarnation.cost = {"mp":30};
	woollyShieldIncarnation.calcDmg = function(sourceChar,targetChar){
		return sourceChar.stats["def"] + sourceChar.stats["res"];		
	}
	woollyShieldIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["def"] += this.dmg;
		
		// MP cost
		this.processCost(sourceChar);
	}
	woollyShieldIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" puffs out "+sourceChar.getPronoun_gen()+" hair, approximating thick wool as best "+sourceChar.getPronoun_nom()+" can, and jumps in front of "+targetChar.name+", intent on protecting "+targetChar.getPronoun_obj()+" with "+sourceChar.getPronoun_gen()+" woolly life!";	
	} 
	
	/**
	Maenad Frenzy deals ATK+CHA to self and (ATK+CHA)*2 to target
	*/
	var maenadFrenzyIncarnation = window.incarnationsDict["maenad_frenzy"];
	maenadFrenzyIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	maenadFrenzyIncarnation.cost = {"mp":10};//,"hp":maenadFrenzyIncarnation.dmg/2}; // todo: interesting idea, but won't work without proper abl I/O, since we'd need source and target char for calcDmg() to get an accurate readout
	maenadFrenzyIncarnation.calcDmg = function(sourceChar,targetChar){
		return 2*(sourceChar.stats["atk"]+sourceChar.attributes["charisma"]);		
	}
	maenadFrenzyIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] -= this.dmg;
		sourceChar.stats["hp"] -= this.dmg/4;
		
		// MP cost
		this.processCost(sourceChar);
	}
	maenadFrenzyIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return "A manic gleam shines in "+sourceChar.name+"'s eyes as they reflect the brilliant light of the lunatic moon suddenly huge in the sky above.  "+sourceChar.getPronoun_nom()+" embraces "+targetChar.name+" with a violent longing, pleasure driven through to pain before the fires of wild need.  "+targetChar.getPronoun_nom()+" wriggles and tries to escape as "+sourceChar.name+" squeezes "+targetChar.getPronoun_obj()+", but there is no way out.  The embrace tightens and the whipcrack of snapping bone makes the night itself cower.  "+this.dmg+" damage is dealt around the world's unhappiest hug.";	
	} 
	
	/// begin for debug only ///
	/**
	TODO: for debug only -- critToTheDick kills the enemy immediately
	*/
	/*
	var critToDickIncarnation = new window.Incarnation("crit_dick","Crit to the Dick");
	critToDickIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	critToDickIncarnation.cost = {"mp":0};
	critToDickIncarnation.calcDmg = function(sourceChar,targetChar){
		return targetChar.stats.hp;		
	}
	critToDickIncarnation.effect = function(sourceChar,targetChar){
		this.dmg = this.calcDmg(sourceChar,targetChar);
		targetChar.stats["hp"] -= this.dmg;
		
		// MP cost
		this.processCost(sourceChar);
	}
	critToDickIncarnation.generateFlavorText = function(sourceChar,targetChar){
		return sourceChar.name+" says 'f&*k it' and puts a foot directly between "+targetChar.name+"'s legs with the force of a thousand thousand folk who have had just about enough of this sh!t.";	
	} 
	State.variables.characters["player"].incarnations["crit_dick"] = critToDickIncarnation;
	State.variables.characters["player"].stats.hp = 1;
	*/
	/// end for debug only ///
	
	var puckChar = State.variables.characters["puck"];
	puckChar.gender = "male";
	puckChar.attributes["strength"] = 4;
	puckChar.attributes["dexterity"] = 20;
	puckChar.attributes["constitution"] = 10;
	puckChar.attributes["intelligence"] = 22;
	puckChar.attributes["wisdom"] = 6;
	puckChar.attributes["charisma"] = 20;
	puckChar.stats["hp"] = 200;
	puckChar.stats["mp"] = Infinity;
	puckChar.stats["maxHP"] = 150;
	puckChar.stats["maxMP"] = Infinity;
	// todo: these assignments could be replaced with a recompute fn
	puckChar.stats["atk"] = puckChar.attributes["strength"];
	puckChar.stats["def"] = puckChar.attributes["constitution"];
	puckChar.stats["pwr"] = puckChar.getMagicAttributeScore();
	puckChar.stats["res"] = puckChar.getMagicAttributeScore();
	// todo: equip Puck?
	puckChar.entity = new window.Entity({name:"Vicious Mockery"});
	var rapierWit = new window.Incarnation({id:"rapier_wit",name:"Rapier Wit"});
	rapierWit.cost = {"mp":15};
	rapierWit.generateFlavorText = function(sourceChar,targetChar){
		if(targetChar){
			// todo: randomly selected insults based on descriptor tags
			
				var percentage = window.rollPercentage();
				var flavorText = "";
				if(targetChar.gender === "female"){
					if(percentage <= 20){
						var hairWord = "hair";
						if(targetChar.descriptors.body.hair.includes("fur")){
							hairWord = "fur";
						}
						flavorText = sourceChar.name+" accuses "+targetChar.name+" of having "+hairWord+" extensions!  She blushes and bristles with unnatural incapacitating rage, the engineered emotion practically coruscating with Incarnation.";
					}// end 1-20%
					else if(percentage > 20 && percentage <= 70){
						flavorText = "Looking down "+(sourceChar.gender==="female"?"her":"his")+" nose at "+targetChar.name+", "+sourceChar.name+" sniffs and conjectures that the once-sinuous curves of her body have become somewhat oblong... and lumpy!  She reels in bizarre anguish as the taunt burrows into her psyche.";
					}//end 21-70%
					else if(percentage > 70 && percentage <= 100){
						flavorText = sourceChar.name+" sniffs the air and then wrinkles "+(sourceChar.gender==="female"?"her":"his")+" nose in disgust, accusing "+targetChar.name+" of stinking like a bog.  Incarnate self-consciousness floods her neurons and she can't be sure of herself!" 
					}//end 71-100%
				}else if(targetChar.gender === "male"){
					if(percentage <= 50){
						flavorText = sourceChar.name+" sizes up "+targetChar.name+" and smirks, informing "+targetChar.name+" that his musculature is reminiscent of a doddering and decrepit elder.  His eyes burn cherry-red as Incarnate rage strangles his mind.";
					}else{
						flavorText = sourceChar.name+" takes a long hard look below "+targetChar.name+"'s belt and then scoffs, clearly underwhelmed.  Venemous doubt Incarnate seeps into the cracks of his self-image and harden there, shattering it!";	
					}
				}else{
					flavorText = sourceChar.name+" points and laughs in a literally cutting fashion!";
				}
				return flavorText + "  The terrible insult leaves tangible scars upon "+targetChar.name+"'s poor soul to the tune of "+this.dmg+" damage!";
		}// end if a targetChar is given
		else{
			return sourceChar.name+" points and laughs in a literally cutting fashion!"
		}
		
		
	}
	rapierWit.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	rapierWit.calcDmg = function(sourceChar,targetChar){
		// highly variable damage sourced from source CHA and resisted slightly by target CHA
		return window.rollDie(6) *window.calcMod(sourceChar.attributes["charisma"]) - window.calcMod(targetChar.attributes["charisma"]);	
	}
	rapierWit.effect = function(sourceChar,targetChar){
		this.dmg = rapierWit.calcDmg(sourceChar,targetChar);
		targetChar.stats.hp -= this.dmg;
		window.addUniqueStatusEffect(targetChar,doubtStatusEffect);
		
		// possible player death processing
		// todo: move this and similar common abl processes to a common abl I/O
		if(targetChar.stats.hp <= 0){
			targetChar.living = false;
		}
		
		// MP cost
		this.processCost(sourceChar);
	}
	puckChar.incarnations["rapier_wit"] = rapierWit;
	
	var rainOfRadiance = new window.Incarnation({id:"rain_of_radiance",name:"Rain of Radiance"});
	rainOfRadiance.cost = {"mp":50};
	rainOfRadiance.generateFlavorText = function(sourceChar,targetChars){
			return sourceChar.name+" thrusts a hand towards the heavens, muscles quivering with equal parts strain and anticipation.  The first few glittering droplets of liquid blue-white starlight are beautiful, but their virtue is quickly eclipsed by a tide of agony that grips the entire party as their flesh/fur is scorched/singed by celestial fire!  "+this.dmg+" horrifically burning damages to the whole party!";	
	}
	rainOfRadiance.targetType = window.Ability.TargetTypesEnum.allEnemies;
	rainOfRadiance.calcDmg = function(sourceChar,targetChar){
		// 'starlight dmg' cuts through defenses and thus cannot be reduced by targetChar attrs... sure.
		var sourcePower = sourceChar.stats["pwr"];
		//alert(sourceChar.name+"'s pwr is "+sourcePower);
		console.log("Power of "+sourceChar.name+" is "+sourcePower);
		return 5*window.calcMod(sourcePower);
	}
	/**
	Rain of Radiance expects an array of target chars since it hits all enemies
	*/
	rainOfRadiance.effect = function(sourceChar,targetChars){
		// note: most of the time you can't have a single dmg calculated for a group abl since usually the source and target char are taken into account in the calcDmg().  Not for this one, though!
		this.dmg = rainOfRadiance.calcDmg(sourceChar,targetChars);
		for(let target of targetChars){
			target.stats.hp -= 	this.dmg;
			console.log(this.dmg+" damage dealt to "+target.name);
			// possible player death processing
			if(target.stats.hp <= 0){
				target.living = false;
			}
		}
		
		// mp cost
		this.processCost(sourceChar);
	}
	puckChar.incarnations["rain_of_radiance"] = rainOfRadiance;
	
	var swordsDance = new window.Incarnation({id:"swords_dance",name:"Swords Dance"});
	swordsDance.cost = {"mp":15};
	swordsDance.generateFlavorText = function(sourceChar,targetChar){
		var flavorString = "Cruel cold light gleams in "+targetChar.name+"'s eyes as warrior spirits torn directly from the savagery of the Wild Hunt meld with "+(targetChar.gender === "female"?"her":"his")+" spirit!";
		if(targetChar.descriptors.body.size === "fun_sized"){
			flavorString += "  You didn't think such a petite individual could strike terror in your heart with mere physical presence, but it seems you were wrong."	
		}else if(targetChar.descriptors.body.size === "party_sized"){
			flavorString += "  You didn't think "+(targetChar.gender === "female"?"her":"his")+" physical presence could loom any larger, but it seems you were wrong."
		}
		
		return flavorString;
	}
	swordsDance.targetType = window.Ability.TargetTypesEnum.singleAlly;
	swordsDance.effect = function(sourceChar,targetChar){
		window.addUniqueStatusEffect(targetChar,bloodlustStatusEffect);	
		
		// mp cost
		this.processCost(sourceChar);
	}
	puckChar.incarnations["swords_dance"] = swordsDance;
	
	puckChar.runAI = function(combat,role){
		alert("reached Puck runAI fn... have fn!  Speaking of, puckChar variable at this point says "+puckChar);
		if(role){
			if(role === "enemy"){
				var chosenAbility = undefined;
				var chosenTarget = undefined;
				
				/*
				// todo: for debug only
				// just hammer away at the Player to test death detection
				this.abilities["attack"].effect(this,State.variables.characters["player"]);
				combat.combatLogContent = this.abilities["attack"].generateFlavorText(this,State.variables.characters["player"]);
				return;
				// end for debug only
				*/

				/* todo: Puck enemy AI behavior	
					 x1. Primary behavior should be randomly chosen abl, with weights towards the Incarnations (though he won't use Swords Dance if he's already got Bloodlust on).
					 TODO: need to add checks for hp <= 0 so Puck doesn't wind up obsessively flogging corpses while the player shrugs and stabs him to death.
					 x2. If Puck's HP is less than 50% and he does not have any mental debuffs (including those imposed by Bloodlust), spam Rain of Radiance.
					 x2. [Dimplomancy Scenario] If anyone has just been healed, use Rain of Radiance. UPDATE: actually, this might be OP.  Also, so far I've avoided building stateful infrastructure with combat history intel, and I'd prefer to continue avoiding that for the demo!
					 x3. [Viral Violence] If a physically frail character is under 50% hp and Puck is Bloodlusted, he Attacks that character.
					 x4. [Surgical Systems] If any player character has an offensive buff (e.g. from Dr. Beakman), focus fire that character with Rapier Wit if they don't already have Doubt.  If all offensively buffed characters already have Doubt, nuke w/ Rain of Radiance.
				*/
				// todo: Since I don't particularly want to toss more abilities onto him to handle the various godling strat paths, it might be best to just modify the AI to be differently aggressive based on the player's chosen path.  That makes more sense with the Entity thing anyhow.
				// todo: where is the disparity between characters character objects and those in other arrays like combat.playerParty coming from?
				var playerParty = [];
				for(let playerCharacter of combat.playerParty){
					playerParty.push(State.variables.characters[playerCharacter.id]);
					console.log("attempting to add character with id "+playerCharacter.id);
					console.log("added "+State.variables.characters[playerCharacter.id].name+" to playerParty");
				}
				// playerParty[0] = State.variables.characters["player"]; // draw out the PLayer from Characters dictionary to see if that makes a difference in UI showing damage from Puck abls UPDATE: yup, that did it for some reason.
				var enemyParty = [];
				for(let enemyCharacter of combat.enemyParty){
					enemyParty.push(State.variables.characters[enemyCharacter.id]);
				}
				
				// outliers and statistical points of interest
				var playerLeastDefense = State.variables.characters["player"];
				var playerLeastHP = State.variables.characters["player"];
				var playerWithTargetBuff = undefined;
				var anyPlayerOffenseBuffed = false;
				var maxHealth = true; // assume true and let contradiction flip it
				
				/// begin gathering data and potentially exiting to Rapier Wit on any buffed player character ///
				for(let player of playerParty){
					
					// overwrite player with least defense if applicable
					if(player.stats["def"] < playerLeastDefense.stats["def"]){
						playerLeastDefense = player;	
					}
					
					// overwrite player with least HP if applicable
					if(player.stats.hp < playerLeastHP.stats.hp){
						playerLeastHP = player;	
					}
					
					if(player.statusEffects.length > 0){
						var statuses = player.statusEffects;
						for(let status of statuses){
							if(status.buffity === "buffins"){
								// buff discovered on this player!  Get 'im!
								// todox: consider removing or deprioritizing this exit cond since it trumps the story scenario checks currently and those can't be moved above basic data gathering
								/*
								this.incarnations["rapier_wit"].effect(this,player);
								return;
								*/
								
								if(status.descriptors.includes("offense")){
									 anyPlayerOffenseBuffed = true;
									 if( !window.hasStatusEffect(player,window.statusEffectsDict["doubt"])){
									playerWithTargetBuff = player;	
								}
							 }
							}
						}// end for each status on current player char
					}// end if current player has statuses
					
					// check for max health scenario flip
					if(player.stats.hp < player.stats.maxHP){
						maxHealth = false;	
					}
					
				}// end for each player
				/// end gathering data + maybe buff balancing ///
				
				/// begin story scenario modifier processing ///
				if(State.variables.godling_strat_chosen === window.godling_strat_viral_violence){
					if(playerLeastDefense.stats.hp < playerLeastDefense.stats.maxHP/2){
						// if the player char with least def is bloodied...
						if(window.hasStatusEffect(this,window.statusEffectsDict["bloodlust"])){
							// if Puck already has bloodlust, go ahead and clobber the poor sucker with lowest defense and HP < 50%
							/*
							this.abilities["attack"].effect(this,playerLeastDefense);
							combat.combatLogContent = this.abilities["attack"].generateFlavorText();
							return;
							*/
							chosenAbility = this.abilities["attack"];
							chosenTarget = playerLeastDefense;
						}else{
							// Puck doesn't have bloodlust yet, so get it!
								/*
								this.incarnations["swords_dance"].effect(this,this);
							combat.combatLogContent = this.incarnations["swords_dance"].generateFlavorText();
							
							return;
							*/
							chosenAbility = this.incarnations["swords_dance"];
							chosenTarget = this;
						}
					}
				}else if(State.variables.godling_strat_chosen === window.godling_strat_surgical_system){
					// hit the latest player with a buff with debuff to balance the ol' scales
					if(playerWithTargetBuff){
							if(!window.hasStatusEffect(playerWithTargetBuff,window.statusEffectsDict["doubt"])){
							
/*								this.incarnations["rapier_wit"].effect(this,playerWithTargetBuff);
								combat.combatLogContent = this.incarnations["rapier_wit"].generateFlavorText();
								return;
								*/
								chosenAbility = this.incarnations["rapier_wit"];
								chosenTarget = playerWithTargetBuff;
						}// end if player with target buff does not already have doubt
						else if(anyPlayerOffenseBuffed){
							// presumably in this case every character with an offensive buff already has doubt.  With our scale balancing work done, just fry 'em with Rain of Radiance!
							
/*							this.incarnations["rain_of_radiance"].effect(this,combat.playerParty);
							combat.combatLogContent = this.incarnations["rain_of_radiance"].generateFlavorText();
							return;
							*/
							chosenAbility = this.incarnations["rain_of_radiance"];
							chosenTarget = playerParty;
						}
					}
				}else if(State.variables.godling_strat_chosen === window.godling_strat_diplomancy){
					// if everyone is at max HP, use Rain of Radiance to fix that little problem
					if(maxHealth){
							
/*						this.incarnations["rain_of_radiance"].effect(this,combat.playerParty);	
						combat.combatLogContent = this.incarnations["rain_of_radiance"].generateFlavorText();
						return;
						*/
						chosenAbility = this.incarnations["rain_of_radiance"];
						chosenTarget = playerParty;
					}
				}
				
				/// end story scenario mod proc ///
				
				/// begin defaults block -- at this point in the script, if Puck has not already picked an abl he will either do one mostly at random OR spam Rain of Radiance if his health is below 50% ///
			if(chosenAbility === undefined && chosenTarget === undefined){
				if(this.stats.hp > this.stats.maxHP/2){
					// rando time!
				var percentageRandoAbl = window.rollPercentage();
				/* wtf
				// establish a random percentage which will be used to select a player party member
				var randoAtkTargetRange = window.rollPercentage();
				// the mapping between percentage and player party indices, e.g. 4 player chars -> 100/4 = 25 -> every 25% we figure the index needs to increment
				var playerPartyRangeChunk = 100/combat.playerParty.length;
				// todo: this does not result in a reasonable index -- if party length is 1,
				// we end up with a percentage like 66/100, which gives us an index of 0.66
				// and playerRandoTarget winds up undefined.
				// The thing you'd need to do is round playerAtkTargetRange to the nearest multiple of 
				// playerPartyRangeChunk.  Then divide by playerPartyRangeChunk and subtract 1 for zero indexing.
				// But why?  All we want here is a random integer from 0 to player party length-1
				*/
				// choose a player party index randomly and pull the poor person from it for targeting
				var playerRandoTarget = playerParty[Math.floor(Math.random()*playerParty.length)];
				
				if(percentageRandoAbl <= 35){
					// todo: maybe consider targeting player with least HP if the least HPness is relatively greater than the least defenseness (relative standing)?
			
/*					this.abilities["attack"].effect(this,playerLeastDefense);
					combat.combatLogContent = this.abilities["attack"].generateFlavorText();
					return;
					*/
					chosenAbility = this.abilities["attack"];
					chosenTarget = playerLeastDefense;
				}else if(percentageRandoAbl > 35 && percentageRandoAbl <= 65){
					
/*					this.incarnations["rapier_wit"].effect(this,playerRandoTarget);
					combat.combatLogContent = this.incarnations["rapier_wit"].generateFlavorText();
					return;
					*/
					chosenAbility = this.incarnations["rapier_wit"];
					chosenTarget = playerRandoTarget;
				}else if(percentageRandoAbl > 65 && percentageRandoAbl <= 85){
					
					if(!window.hasStatusEffect(this,window.statusEffectsDict["bloodlust"])){					
/*						this.incarnations["swords_dance"].effect(this,this);	
																																																				combat.combatLogContent = this.incarnations["swords_dance"].generateFlavorText();
																																																				return;
																																																				*/
						chosenAbility = this.incarnations["swords_dance"];
						chosenTarget = this;
																																								}else{

						// Puck already has Bloodlust, so do the atk strat
																																									
																																			/*						this.abilities["attack"].effect(this,playerLeastDefense);	
																																									combat.combatLogContent = this.abilities["attack"].generateFlavorText();
																																								return;
																																									*/
																																									chosenAbility = this.abilities["attack"];
																																									chosenTarget = playerLeastDefense;
																																								}
				}else{
					
/*					this.incarnations["rain_of_radiance"].effect(this,combat.playerParty);	
					combat.combatLogContent = this.incarnations["rain_of_radiance"].generateFlavorText();
					return;
					*/
					chosenAbility = this.incarnations["rain_of_radiance"];
					chosenTarget = playerParty;
				}// end rando time
			 }// end Puck HP > 50%
			 else{
			 	// being severely injured, Puck now starts to spam Rain of Radiance if no earlier behaviors were proced
				 
/*				 this.incarnations["rain_of_radiance"].effect(this,combat.playerParty);
				 combat.combatLogContent = this.incarnations["rain_of_radiance"].generateFlavorText();
				 return;
				 */
				 chosenAbility = this.incarnations["rain_of_radiance"];
				 chosenTarget = playerParty;
			 }
			} // end if abl and target are not yet chosen, landing us in defaults
			/// end defaults block ///
				
				// todo: consider finding a way to wrap specific AI in common AI handling, such that confusion/charm etc. handling like this can be common to all characters' AI scripts.
		
// todo: if confused, reassign chosenTarget with 50% self-target and 50% original target(s)
				// todo: this reassignment would ideally take ability target types into account
				if(window.hasStatusEffect(this,window.statusEffectsDict["confuse"])){
					
// confuse's effect is to roll percentage and return true if value is > 50
					if(window.getStatusEffect(this,"confuse").effect()){
						chosenTarget = this;	
					}
			}
			else if(window.hasStatusEffect(this,window.statusEffectsDict["charm"])){
				var charmStatusInstance = window.getStatusEffect(this,"charm");
				var charmingCharacterId = charmStatusInstance.sourceCharacterId;
					if(chosenTarget.id === charmingCharacterId){
						 // rando reassign to someone other than charming character
						chosenTarget = randoCharacterFromArrayExceptId(combat.getAllCombatants(),charmingCharacterId);
					}
			}
				
				 // todo: how should individual potential target combat flags work together with abilities whose effect API expects an entire party of targets?  One target with wonder wall should not stop the abl from hitting others on the one hand, and on the other the walled character needs to not have the abl effect applied to them and should proc the wall of wonder reprisal.
				// UPDATE: create a set of chosen targets, even if only one.  Then step through and check for wall of wonder protection.  If found, remove the walled character from the set of targets and apply wall reprisal.  After iteration is complete, send the remaining target set into the chosen ability.
				// since chosen target could be one or more, create an array if there is only one and then we can still just iterate over it
			var targets = undefined;	
			if(chosenAbility.targetType === window.Ability.TargetTypesEnum.allEnemies){
				console.log("setting AI targets to array "+chosenTarget+" which starts with "+chosenTarget[0].name);
				targets = chosenTarget;
			}else{
				// in this case there is only one target, but by wrapping it in an array we can proceed with equivalent loop code below
				console.log("setting AI target to array wrapping the single target "+chosenTarget+" with name "+chosenTarget.name);
				targets = [chosenTarget];	
			}
				
				// process combat flags on the chosen target(s)
				for(let target of targets){
					if(target.combatFlags & window.Character.CombatFlags.FLAG_WONDER_WALLED === window.Character.CombatFlags.FLAG_WONDER_WALLED){
				// lower the wonder wall flag
				target.combatFlags &= ~window.Character.CombatFlags.FLAG_WONDER_WALLED;
				
				// the combat log content should reflect the bounce off the wall and any and all reprisals concatenated
				combat.combatLogContent = "BZZzzzrrr--SHING!\n";
						
				// remove the walled character from the chosenTarget array
						window.removeCharacterFromArray(target,targets);
				
				// generate a random effect, dmg or status, to direct back at Puck
						var incarnationKeys = Object.keys(window.incarnationsDict);
						var randoIncarnationIndex = Math.floor(Math.random() * incarnationKeys.length);
				
				// apply the effect to Puck
				var randoReprisalAbility = window.incarnationsDict[incarnationKeys[randoIncarnationIndex]];
						randoReprisalAbility.effect(this);
						// todo: need support for abilities going off without a caster/target.  For the demo, simply saying Miss Fortune for wielder and Puck for target of rando wall of wonder effect is fine.
						combat.combatLog += radnoReprisalAbility.generateFlavorText(new Character({id:"miss_fortune",name:"Miss Fortune"}),this);
				
				}// end wall of wonder flag processing
			}// end combat flag processing loop for target(s)
				
				console.log("AI chose the ability "+chosenAbility.name);
				// todo: easiest way to have cost still applied to the ability even if there are now 0 targets is to fire off the effect over an empty array.  Trouble is that most abl effect functions were not written expecting an array of targets, and even those that do don't check for an empty array explicitly which might matter depending on how we use the array in effect().  May want to re-write those APIs to make it a standard array of target chars, but for the moment simply sourcing the target type of the chosen ability should suffice.  However, that still procs undefined ref errors since effect() doesn't check for undefined target(s).  Way around that is to apply the cost of the ability separately and then skip the effect() call and the usual flavor text if the targets array is empty.
				if(targets.length > 0){
					// there are still targets, so go forward with them as per usual
					if(chosenAbility.targetType === window.Ability.TargetTypesEnum.allEnemies){

						// multi-target attack, expects an array of chars as target	
					chosenAbility.effect(this,targets);
					combat.combatLogContent = chosenAbility.generateFlavorText(this,targets);

					for(let targetKey in targets[0]){
						console.log("target "+targets[0]+" with name "+targets[0].name+" has prop: "+targetKey);
					}

					console.log(targets[0].name+"'s hp is now "+targets[0].stats.hp+" and specifically the human's HP is "+State.variables.characters["player"].stats.hp);
						
					}else{
						// single target attack, expects only single character as target
						chosenAbility.effect(this,targets[0]);
					combat.combatLogContent = chosenAbility.generateFlavorText(this,targets[0]);

					for(let targetKey in targets[0]){
						console.log("target "+targets[0]+" with name "+targets[0].name+" has prop: "+targetKey);
					}

					console.log(targets[0].name+"'s hp is now "+targets[0].stats.hp+" and specifically the human's HP is "+State.variables.characters["player"].stats.hp);
					}
				}else{
					// abl cost is an object map with keys that match the mutable resource stats... completely on purpose and by design, that was.
					for(costElement in chosenAbility.cost){
						this.stats[costElement] -= chosenAbility.cost[costElement];	
					}
				}// end if no targets left after flag processing, so only abl cost is applied
				
				console.log("Puck's chosen abl is "+chosenAbility.name+" with first target named "+targets[0].name);
			}// if role is enemy
		}// if role is defined
	}//end Puck AI def
	
	
	var marrahChar = State.variables.characters["marrah"];
	marrahChar.gender = "female";
	marrahChar.stats["hp"] = 40;
	marrahChar.stats["mp"] = 70;
	marrahChar.stats["maxHP"] = 40;
	marrahChar.stats["maxMP"] = 70;
	marrahChar.attributes["strength"] = 12;
	marrahChar.attributes["dexterity"] = 18;
	marrahChar.attributes["constitution"] = 10;
	marrahChar.attributes["intelligence"] = 14;
	marrahChar.attributes["wisdom"] = 8;
	marrahChar.attributes["charisma"] = 20;
	marrahChar.stats["atk"] = marrahChar.attributes["strength"];
	marrahChar.stats["def"] = marrahChar.attributes["constitution"];
	marrahChar.stats["pwr"] = marrahChar.getMagicAttributeScore();
	marrahChar.stats["res"] = marrahChar.getMagicAttributeScore();
	marrahChar.entity = new window.Entity({name:"Kitsune"});
	
	
	// Haunted Fey can Terrify opponent, causing them to randomly skip turns
	var hauntedFey = new window.Incarnation({id:"haunted_fey",name:"Haunted Fey"});
	marrahChar.incarnations["haunted_fey"] = hauntedFey;
	console.log("Marrah's first incarnation is "+marrahChar.incarnations[Object.keys(marrahChar.incarnations)[0]].name);
	hauntedFey.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	hauntedFey.cost = {"mp":20};
	hauntedFey.effect = function(sourceChar,targetChar){
		var savingThrow = targetChar.saves["will"] + window.rollD20();
		// effect will be called on the Incarnation instance, so this should be bound to same
		if(savingThrow <= this.calcDC(marrahChar,"charisma")){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["terror"]);	
		}
		
		// cost
		this.processCost(sourceChar);
	}// end defining effect of haunted_fey
	hauntedFey.generateFlavorText = function(sourceChar,targetChar){
		// todo: this is a perfect opportunity for "generative text"; nothing too fancy, basically randomized madlibs sort of thing is what I was thinking, but maybe with some slight inductive bias/target and source character descriptor consideration weighing the randomness used in populating the blanks.
		return sourceChar.name+"'s visage shimmers as reality warps around "+sourceChar.getPronoun_gen()+" body.  In the next instant, "+sourceChar.getPronoun_nom()+" has been replaced by something born of the very fabric of nightmare -- the creature's flesh is withered and weathered, and blood oozes from innumerable splits in what appear to be surgical seams all along its abominable body.  Horns and claws extend from odd places, and fangs sprout from everywhere.  Wherever you look, there's another drooling mouth with a lashing, searching tongue covered in wicked barbs.  The eyes concern you the most, however: there is an alienness to them that you can't clearly define, but which speaks to you of unfathomable depths in the emptiness between the stars... and all that lurks there.  A moment later the horror is gone and "+sourceChar.name+" stands there as if nothing had happened, a smile all of teeth on "+sourceChar.getPronoun_gen()+" face as "+sourceChar.getPronoun_nom()+" surveys the anarchy "+sourceChar.getPronoun_nom()+" has inspired in the foebeasts' ranks!";
	}
	
	var foxFire = new window.Incarnation({id:"fox_fire",name:"Fox Fire"});
	marrahChar.incarnations["fox_fire"] = foxFire;
	foxFire.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	foxFire.cost = {"mp":15};
	foxFire.calcDmg = function(sourceChar,targetChar){
		// dmg based on source's cur:max MP ratio
		var magicRat = sourceChar.stats.mp/sourceChar.stats.maxMP;
		
		// the max damage possible is based on MP and will be reduced by any magicRat less than 1
		return magicRat*(sourceChar.stats.maxMP); //so Marrah will start at max 70 damage, which is a little over triple the normal attack damage.
		
	}
	foxFire.effect = function(sourceChar,targetChar){
		/* // shouldn't be able to save against the whole thing, plus the Puck fight for the demo is a bit on the too hard side
		// apply status effect, doubt
		var savingThrow = targetChar.saves["will"] + window.rollD20();
		// effect will be called on the Incarnation instance, so this should be bound to same
		if(savingThrow <= this.calcDC(marrahChar,"charisma")){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["doubt"]);
			
			// set dmg
			this.dmg = this.calcDmg(sourceChar,targetChar);
			
			// deal dmg
			targetChar.stats.hp -= this.dmg;
		}
		*/

		window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["doubt"]);
			
			// set dmg
			this.dmg = this.calcDmg(sourceChar,targetChar);
			
			// deal dmg
			targetChar.stats.hp -= this.dmg;
		
		// cost
		this.processCost(sourceChar);
	}
	foxFire.generateFlavorText = function(sourceChar,targetChar){
		// todo: generic version
		return "Marrah's brilliant scarlet fur stands on end as static electricity fills the air, along with a menacing hum.  Her yellow eyes flash electric blue for a moment and she puts both paws over her heart.  Closing her eyes, she inhales deeply, her chest puffing out proud and strong, as she allows her awareness to cascade inward.  The world waits on her discovery for a few moments, and then her eyes fly wide open -- they are glowing a painfully bright ruby with a molten gold corona.  Eight tails forged from fires of every imaginable hue, from ghostly green to putrescent purple, join her only slightly less magical normal one. She turns tail and flicks all nine dismissively towards "+targetChar.name+".  The technicolor flames leap from Marrah with gleeful fervor, and engulf "+targetChar.getPronoun_obj()+" for "+this.dmg+" damage!";	
	}
		
	var ghostWhip = new window.Incarnation({id:"ghost_whip",name:"Ghost Whip"});
	marrahChar.incarnations["ghost_whip"] = ghostWhip;
	ghostWhip.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	ghostWhip.cost = {"mp":15};
	ghostWhip.calcDmg = function(sourceChar,targetChar,aspect){
		if(aspect === "meat"){
			// CHA vs. CON to damage HP and give half to source
			return 10+sourceChar.attributes["charisma"]-targetChar.attributes["constitution"];
			
		}else if(aspect === "mind"){
			// CHA vs. CHA to damage MP and give half to source
			return 10+sourceChar.attributes["charisma"]-targetChar.attributes["charisma"];
		
		}
	}
	ghostWhip.effect = function(sourceChar,targetChar){
		this.hpDmg = this.calcDmg(sourceChar,targetChar,"meat");
		this.mpDmg = this.calcDmg(sourceChar,targetChar,"mind");
		targetChar.stats.hp -= this.hpDmg;
		targetChar.stats.mp -= this.mpDmg;
		sourceChar.stats.hp += this.hpDmg/2;
		sourceChar.stats.mp += this.mpDmg/2;
		
		// cost
		this.processCost(sourceChar);
	}
	ghostWhip.generateFlavorText = function(sourceChar,targetChar){
		// todo: reference hpDmg and mpDmg instead of dmg!
		return "A whip of pale iridescent light appears in "+sourceChar.name+"'s paw, and "+sourceChar.getPronoun_nom()+" cracks it with a liquid flourish, shattering stillness.  "+targetChar.name+" recoils in horror as the whip passes through "+targetChar.getPronoun_gen()+" body and appears to wrap directly around "+targetChar.getPronoun_gen()+" heart.  A goofy grin crawls across "+sourceChar.name+"'s face as the light of will and life pulses back along the whip to "+sourceChar.getPronoun_obj()+" like blood through a glutted leech.  "+sourceChar.getPronoun_gen()+" eyelids flutter and "+sourceChar.getPronoun_gen()+" eyes roll in a mild ecstasy as pilfered personhood flows into "+sourceChar.getPronoun_obj()+"...  That'll be "+this.hpDmg+" damage to "+targetChar.getPronoun_gen()+" body and "+this.mpDmg+" to "+targetChar.getPronoun_gen()+" mind!";
	}
	
	/**
	Fire Claw combines Incarnation power with physical attack power to inflict heavy damage
	*/
	var fireClawIncarnation = new window.Incarnation({id:"fire_claw",name:"Fire Claw"});
		marrahChar.incarnations["fire_claw"] = fireClawIncarnation;
		fireClawIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
	fireClawIncarnation.cost = {"mp":5,"hp":5};
		fireClawIncarnation.calcDmg = function(sourceChar,targetChar){
				return sourceChar.stats["pwr"]+sourceChar.stats["atk"];
		}
		fireClawIncarnation.effect = function(sourceChar,targetChar){
				this.dmg = this.calcDmg(sourceChar,targetChar);
				targetChar.stats["hp"] -= this.dmg;
			
			// cost
			this.processCost(sourceChar);
		}
		fireClawIncarnation.generateFlavorText = function(sourceChar,targetChar){
			// todo: add randomness to abl text, modified by wielder and maybe target descriptor tags
			// todo: add non-Marrah text
			
			// Marrah specific text
			return "Marrah spins in a blur of scarlet and as the sheer frenzy of her motion whips up wind around her, a bonfire of pure passion erupts from nowhere and wraps her in a gorgeously deadly veil.  In the midst of a blinding nova through which only the sleek curves of her silhouette can be seen, she halts with a flourish of her bushy tail and extends a slender paw flirtatiously towards "+targetChar.name+", crooking a finger in all-too-warm invitation.  The wild nova gathers itself into tongues that lick their languid way over her body to coalesce around her arm.  Before "+targetChar.getPronoun_nom()+" can flee, she darts forward and slashes "+targetChar.getPronoun_obj()+" with flaming claws that dig out grisly-deep ("+this.dmg+" HP deep) tracks of sizzling flesh!";
		}
		
	var mootyChar = State.variables.characters["mooty"];
	mootyChar.gender = "male";
	mootyChar.stats["hp"] = 65;
	mootyChar.stats["mp"] = 50;
	mootyChar.stats["maxHP"] = 65;
	mootyChar.stats["maxMP"] = 50;
	mootyChar.attributes["strength"] = 18;
	mootyChar.attributes["dexterity"] = 8;
	mootyChar.attributes["constitution"] = 14;
	mootyChar.attributes["intelligence"] = 12;
	mootyChar.attributes["wisdom"] = 20;
	mootyChar.attributes["charisma"] = 13;
	mootyChar.stats["atk"] = mootyChar.attributes["strength"];
	mootyChar.stats["def"] = mootyChar.attributes["constitution"];
	mootyChar.stats["pwr"] = mootyChar.getMagicAttributeScore();
	mootyChar.stats["res"] = mootyChar.getMagicAttributeScore();
	mootyChar.entity = new window.Entity({name:"Burrower"});
	
	// todo: all these private Incarnations should be moved to the public Incarnations dict, unless there is some reason The Human should not be able to learn them
		
		/**
		Regenerator adds regen to the target
		*/
	var regeneratorIncarnation = new window.Incarnation({id:"regenerator",name:"Regenerator"});
		mootyChar.incarnations["regenerator"] = regeneratorIncarnation;
		regeneratorIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
		regeneratorIncarnation.cost = {"mp":10};
		regeneratorIncarnation.effect = function(sourceChar,targetChar){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["regen"]);	
			
			// mp cost
			this.processCost(sourceChar);
		}
		regeneratorIncarnation.generateFlavorText = function(sourceChar, targetChar){
			return sourceChar.name+" pours "+sourceChar.getPronoun_gen()+" empathy and will to protect into a tangible force, and it forms a gossamer veil that sparkles as if cut from sapphire around "+targetChar.name;
		}
		/**
		Spring Rain heals the entire party
		*/
	var springRainIncarnation = new window.Incarnation({id:"spring_rain",name:"Spring Rain"});
		mootyChar.incarnations["spring_rain"] = springRainIncarnation;
		springRainIncarnation.targetType = window.Ability.TargetTypesEnum.allAllies;
		springRainIncarnation.cost = {"mp":20};
		springRainIncarnation.calcDmg = function(sourceChar,targetChar){
			// healed based on the wielder's pwr and how much the wielder likes the target
			var likeFactor = targetChar.affinities[sourceChar.id];
			if(likeFactor !== undefined){
				return 1.5*(sourceChar.stats["pwr"]+likeFactor);
			}else{
				return 1.5*sourceChar.stats["pwr"];
			}
		}
		springRainIncarnation.effect = function(sourceChar,targetChars){
			for(let targetChar of targetChars){
				targetChar.stats["hp"] += this.calcDmg(sourceChar,targetChar);
			}
			// mp cost
			this.processCost(sourceChar);
		}
		springRainIncarnation.generateFlavorText = function(sourceChar, targetChar){
			return "A friendly little cloud whose only stormy spots seem to form a smiling expression gathers over the party as "+sourceChar.name+" extols "+sourceChar.getPronoun_gen()+" love for them.  Warm revitalizing rain washes over the party, closing wounds and raising spirits all around!";
		}
		
		/**
		Grief Howl returns a deceased ally to life  
		*/
	var griefHowlIncarnation = new window.Incarnation({id:"grief_howl",name:"Grief Howl"});
		mootyChar.incarnations["grief_howl"] = griefHowlIncarnation;
		griefHowlIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
		griefHowlIncarnation.cost = {"mp":30};
		griefHowlIncarnation.calcDmg = function(sourceChar,targetChar){
			// healed for maxHP/2 plus how much the wielder likes the target
			var likeFactor = targetChar.affinities[sourceChar.id];
			if(likeFactor !== undefined){
				return targetChar.stats["maxHP"]/2+likeFactor;
			}else{
				return targetChar.stats["maxHP"]/2;
			}
		}
		griefHowlIncarnation.effect = function(sourceChar,targetChar){
			// remove dead status and heal for calcDmg()
			targetChar.living = true;
			
			// first return HP to 0 baseline
			targetChar.stats["hp"] = 0;
			
			// then heal based on calcDmg()
			targetChar.stats["hp"] += this.calcDmg(sourceChar,targetChar);
			
			// todo: check living status during combat and when heals/dmg/targeting occurs (specifically for the demo with only a single enemy relative to the player: allAllies abilities should not hit nonliving party members, singleAlly abilities should not be able to target them, runAI()::singleEnemy should not choose them as target, and runAI()::allEnemies should not hit nonliving targets).
			
			// mp cost
			this.processCost(sourceChar);
		}
		griefHowlIncarnation.generateFlavorText = function(sourceChar, targetChar){
			return sourceChar.name+" tosses back "+sourceChar.getPronoun_gen()+" head and howls at the sky, mourning the loss of "+targetChar.name+".  The weight of "+sourceChar.getPronoun_gen()+" grief is so overwhelming that reality staggers beneath it, and buckles just enough that "+targetChar.name+"'s spirit can escape the jaws of Death!";
		}
		
	var drbeakmanChar = State.variables.characters["drbeakman"];
	drbeakmanChar.gender = "male";
	drbeakmanChar.stats["hp"] = 45;
	drbeakmanChar.stats["mp"] = 65;
	drbeakmanChar.stats["maxHP"] = 45;
	drbeakmanChar.stats["maxMP"] = 65;
	drbeakmanChar.attributes["strength"] = 8;
	drbeakmanChar.attributes["dexterity"] = 10;
	drbeakmanChar.attributes["constitution"] = 10;
	drbeakmanChar.attributes["intelligence"] = 24;
	drbeakmanChar.attributes["wisdom"] = 10;
	drbeakmanChar.attributes["charisma"] = 10;
	drbeakmanChar.stats["atk"] = drbeakmanChar.attributes["strength"];
	drbeakmanChar.stats["def"] = drbeakmanChar.attributes["constitution"];
	drbeakmanChar.stats["pwr"] = drbeakmanChar.getMagicAttributeScore();
	drbeakmanChar.stats["res"] = drbeakmanChar.getMagicAttributeScore();
	drbeakmanChar.entity = new window.Entity({name:"Tactitian"});
	
	/**
		Vibroblade adds a chainsaw-like kinetic force to the target's weapon! (gives temper status effect)
		*/
	var vibrobladeIncarnation = new window.Incarnation({id:"vibroblade",name:"Vibroblade"});
		drbeakmanChar.incarnations["vibroblade"] = vibrobladeIncarnation;
		vibrobladeIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
		vibrobladeIncarnation.cost = {"mp":10};
		vibrobladeIncarnation.effect = function(sourceChar,targetChar){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["temper"]);	
			
			// mp cost
			this.processCost(sourceChar);
		}
		vibrobladeIncarnation.generateFlavorText = function(sourceChar, targetChar){
			// todo: need a 'get appendages' method that checks the descriptor array for tags that might hint at appendages.  Could even go into more detail with descriptors that are categorized to different details like the character's morphology, and have a subsection for appendages
			return sourceChar.name+" grins wickedly and performs a complicated flourish with "+sourceChar.getPronoun_gen()+" "+sourceChar.descriptors.body.appendages.arms.name+" and "+targetChar.name+"'s weapon begins to vibrate subtley as a razor-swift current of air blows cyclically around its edge.  A soft and supremely satisfying growly purring sound emenates from it; everyone who can backs away slightly.";
		} 
		
	/**
		Laser Sight adds Focus status effect
		*/
	var laserSightIncarnation = new window.Incarnation({id:"laser_sight",name:"Laser Sight"});
		drbeakmanChar.incarnations["laser_sight"] = laserSightIncarnation;
		laserSightIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
		laserSightIncarnation.cost = {"mp":10};
		laserSightIncarnation.effect = function(sourceChar,targetChar){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["focus"]);	
			
			// mp cost
			this.processCost(sourceChar);
		}
		laserSightIncarnation.generateFlavorText = function(sourceChar, targetChar){
			// todo: focus on ether in the surrounding env
			return "Time slows down for "+targetChar.name+" as "+sourceChar.name+" shows "+targetChar.getPronoun_obj()+" how to pull back the veil of our reality and see what lies behind.  The secrets of the universe fell somewhat closer!";
		}
		
	/**
		Fey Touch adds Third Eye status effect
		*/
	var feyTouchIncarnation = new window.Incarnation({id:"fey_touch",name:"Fey Touch"});
		drbeakmanChar.incarnations["fey_touch"] = feyTouchIncarnation;
		feyTouchIncarnation.targetType = window.Ability.TargetTypesEnum.singleAlly;
		feyTouchIncarnation.cost = {"mp":15};
		feyTouchIncarnation.effect = function(sourceChar,targetChar){
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["third_eye"]);	
			
			// mp cost
			this.processCost(sourceChar);
		}
		feyTouchIncarnation.generateFlavorText = function(sourceChar, targetChar){
			// todo: fey granting understanding of multiverse
			return "As "+sourceChar.name+"'s eyes gleam in the direction of "+targetChar.name+", a portal to some place primordial, intense, and above all WILD rends reality in front of "+targetChar.getPronoun_obj()+".  A storm of beings emerge, each shimmering and distorted as a sort of veil of impossibility makes it difficult to focus on them.  The wind of whimsy weaves its way around "+targetChar.name+" for a few moments, then abruptly vanishes along with the portal it (they?) came through.  "+targetChar.name+" looks mostly unaffected, though a feral hunger lurks behind "+targetChar.getPronoun_nom()+" eyes.";
		}
		
	/* this appears to stick in the player retrieved in combat passages	
	var playerChar = State.variables.characters["player"];
	playerChar.incarnations["fey_touch"] = feyTouchIncarnation;
	*/
		
	var shimmerinChar = State.variables.characters["shimmerin"];
	shimmerinChar.gender = "female";
	shimmerinChar.stats["hp"] = 30;
	shimmerinChar.stats["mp"] = 80;
	shimmerinChar.stats["maxHP"] = 30;
	shimmerinChar.stats["maxMP"] = 80;
	shimmerinChar.attributes["strength"] = 6;
	shimmerinChar.attributes["dexterity"] = 20;
	shimmerinChar.attributes["constitution"] = 6;
	shimmerinChar.attributes["intelligence"] = 18;
	shimmerinChar.attributes["wisdom"] = 10;
	shimmerinChar.attributes["charisma"] = 24;
	shimmerinChar.stats["atk"] = shimmerinChar.attributes["strength"];
	shimmerinChar.stats["def"] = shimmerinChar.attributes["constitution"];
	shimmerinChar.stats["pwr"] = shimmerinChar.getMagicAttributeScore();
	shimmerinChar.stats["res"] = shimmerinChar.getMagicAttributeScore();
	shimmerinChar.entity = new window.Entity({name:"Whimsy of Wind"});
	
	/**
		Wall of Wonder: protects each ally from a single attack by the enemy, and inflicts a random negative status or damage on the enemy in retaliation (using the character who cast the Wall Incarnation as the sourceChar). 
		*/
	var wallOfWonderIncarnation = new window.Incarnation({id:"wall_of_wonder",name:"Wall of Wonder"});
		shimmerinChar.incarnations["wall_of_wonder"] = wallOfWonderIncarnation;
		wallOfWonderIncarnation.cost = {"mp":35}
		wallOfWonderIncarnation.targetType = window.Ability.TargetTypesEnum.allAllies;
		wallOfWonderIncarnation.effect = function(sourceChar,targetChars){
			// raise the wall of wonder flag for each allied party member
			for(let target of targetChars){
				target.combatFlags |= window.Character.CombatFlags.FLAG_WONDER_WALLED;	
			}
			
			this.processCost(sourceChar);
		}
		wallOfWonderIncarnation.generateFlavorText = function(sourceChar, targetChars){
			return sourceChar.name+" grins broadly and begins dancing about in the air in impossibly complex patterns.  A faint trail of light lingers where "+sourceChar.getPronoun_nom()+" passes, giving the impression that "+sourceChar.name+" is painting a glorious tableau with extreme haste.  Soon, the tableau becomes a tableau vivant: lights pull together into vague and curious forms, and then beginning to move of their own volition.  By the time "+sourceChar.getPronoun_nom()+"'s finished, there is a small world of magnificent and terrible things zooming about in front of the party.  Their attention, one and all, is locked upon "+sourceChar.name+"'s foes!";
		} 
		
	/**
	Phantasmagoria: whimsical breath full of wonder and horror inextricably merged washes over the foebeasts, damaging and confusing them! (Confused status effect causes 50% chance that whatever abl the confused character chooses to use will be targeted at themselves instead of the original target)	
	*/
		var phantasmagoriaIncarnation = new window.Incarnation({id:"phantasmagoria",name:"Phantasmagoria"});
		shimmerinChar.incarnations["phantasmagoria"] = phantasmagoriaIncarnation;
		phantasmagoriaIncarnation.cost = {"mp":20}
		phantasmagoriaIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
		phantasmagoriaIncarnation.calcDmg = function(sourceChar,targetChar){
			return sourceChar.stats["pwr"]*2 - targetChar.stats["res"];
		}
		phantasmagoriaIncarnation.effect = function(sourceChar,targetChar){
			// apply dmg + Confuse to target
			this.dmg = this.calcDmg(sourceChar,targetChar);
			targetChar.stats["hp"] -= this.dmg;
			window.addUniqueStatusEffect(targetChar,window.statusEffectsDict["confuse"]);
			
			// handle cost to user
			this.processCost(sourceChar);
		}
		phantasmagoriaIncarnation.generateFlavorText = function(sourceChar, targetChar){
			return sourceChar.name+" locks eyes with "+targetChar.name+" and draws in a deep breath.  Gossamer, multi-hued tendrils sway and dance their way through the air from "+targetChar.getPronoun_gen()+" temple to "+sourceChar.getPronoun_gen()+" lips, and a wild, fey gleam steals over her eyes.  "+sourceChar.getPronoun_nom()+" puffs out "+sourceChar.getPronoun_gen()+" cheeks and blows out a capering, dancing, laughing, killing, screaming teeming cloud of phantasmal forms, its shape and color constantly in flux.  These encompass, eclipse, and overwhelm "+targetChar.name+", who hops about madly while variably slashing and grasping longingly at the ephemeral entities.  "+targetChar.name+"'s body seems to wither and decay wherever the beings touch "+targetChar.getPronoun_obj()+", resulting in a lovely "+this.dmg+" damage!";
		}
		
	/**
	Caress of the Zephyr: teases, titillates, and slashes a target.  Deals dmg equal to pwr*2 - def/2 and charms the target (charm makes it so that the target cannot harm the charming character)
	*/
		var caressOfZephyrIncarnation = new window.Incarnation({id:"caress_of_zephyr",name:"Caress of the Zephyr"});
		shimmerinChar.incarnations["caress_of_zephyr"] = caressOfZephyrIncarnation;
		caressOfZephyrIncarnation.cost = {"mp":25}
		caressOfZephyrIncarnation.targetType = window.Ability.TargetTypesEnum.singleEnemy;
		caressOfZephyrIncarnation.calcDmg = function(sourceChar,targetChar){
			return sourceChar.stats["pwr"]*2 - targetChar.stats["def"]/2;	
		}
		caressOfZephyrIncarnation.effect = function(sourceChar,targetChar){
			// todo: dmg + Charm
			this.dmg = this.calcDmg(sourceChar,targetChar);
			targetChar.stats["hp"] -= this.dmg;
			window.addUniqueStatusEffectWithSource(sourceChar,targetChar,window.statusEffectsDict["charm"]);
			
			// handle cost to user
			this.processCost(sourceChar);
		}
		caressOfZephyrIncarnation.generateFlavorText = function(sourceChar, targetChar){
			return sourceChar.name+" bends low toward "+targetChar.name+", as if "+sourceChar.getPronoun_nom()+" is genuflecting.  As "+sourceChar.getPronoun_nom()+" does, "+sourceChar.name+" gracefully moves "+sourceChar.getPronoun_gen()+" "+sourceChar.descriptors.body.appendages.hands.name+" to "+sourceChar.getPronoun_gen()+" lips and blows a teasingly gentle kiss.  The process of lowering "+sourceChar.getPronoun_gen()+" "+sourceChar.descriptors.body.appendages.arms.name+" from the kiss is a fascinating display: it seems to occur in sensual slow motion, and follows the contours of "+targetChar.name+"'s body so perfectly that all in attendance can practically feel "+sourceChar.getPronoun_gen()+" caress.  Needless to say, "+targetChar.name+" is entranced by the display... and "+this.dmg+" damage!";
		}
	
	/* // todo: consider adding Nuvi as a combat character post-demo
	var nuviChar = State.variables.characters["nuvi"];
	
	*/
	
	
	
}// end defining init()

/// begin init ///
init();
/// end init ///









</script>
</head>
<body>
<script>
var combat = new window.Combat({
	playerParty : [State.variables.characters['player']],
	enemyParty : [State.variables.characters['puck']],
	destPassageName : ""
});
console.log("in test script; test combat object playerParty[0].name reports "+combat.playerParty[0].name+" which should match the player from characters dict given as "+State.variables.characters['player'].name);
State.variables.godling_strat_chosen = window.godling_strat_surgical_system;
</script>
<button onclick="State.variables.characters['puck'].runAI(combat,'enemy')">Test</button>
</body>
</html>
